<!DOCTYPE html>
<html>
  <head>
    <title>Deep Learning for NLP Best Practices</title>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">



<link rel="apple-touch-icon" sizes="57x57" href="../assets/img/apple-touch-icon-57x57.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="60x60" href="../assets/img/apple-touch-icon-60x60.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="72x72" href="../assets/img/apple-touch-icon-72x72.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="76x76" href="../assets/img/apple-touch-icon-76x76.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="114x114" href="../assets/img/apple-touch-icon-114x114.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="120x120" href="../assets/img/apple-touch-icon-120x120.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="144x144" href="../assets/img/apple-touch-icon-144x144.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="152x152" href="../assets/img/apple-touch-icon-152x152.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="180x180" href="../assets/img/apple-touch-icon-180x180.png?v=wAAv6Wqe6l">
<link rel="icon" type="image/png" href="../assets/img/favicon-32x32.png?v=wAAv6Wqe6l" sizes="32x32">
<link rel="icon" type="image/png" href="../assets/img/favicon-194x194.png?v=wAAv6Wqe6l" sizes="194x194">
<link rel="icon" type="image/png" href="../assets/img/favicon-96x96.png?v=wAAv6Wqe6l" sizes="96x96">
<link rel="icon" type="image/png" href="../assets/img/android-chrome-192x192.png?v=wAAv6Wqe6l" sizes="192x192">
<link rel="icon" type="image/png" href="../assets/img/favicon-16x16.png?v=wAAv6Wqe6l" sizes="16x16">
<link rel="manifest" href="../assets/img/manifest.json?v=wAAv6Wqe6l">
<link rel="shortcut icon" href="../assets/img/favicon.ico?v=wAAv6Wqe6l">
<meta name="msapplication-TileColor" content="#e74c3c">
<meta name="msapplication-TileImage" content="/assets/img/mstile-144x144.png?v=wAAv6Wqe6l">
<meta name="msapplication-config" content="/assets/img/browserconfig.xml?v=wAAv6Wqe6l">
<meta name="theme-color" content="#e74c3c">
    <link rel="stylesheet" type="text/css" href="../assets/css/uno-zen.css?v=874cc6af7f" />
    <link rel="canonical" href="http://ruder.io/deep-learning-nlp-best-practices/" />
    <meta name="referrer" content="origin" />
    
    <meta property="og:site_name" content="Sebastian Ruder" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Deep Learning for NLP Best Practices" />
    <meta property="og:description" content="A collection of best practices for Deep Learning for a wide array of Natural Language Processing tasks." />
    <meta property="og:url" content="u=http://ruder.io/deep-learning-nlp-best-practices/" />
    <meta property="og:image" content="u=http://ruder.io/content/images/2017/07/attention_bahdanau-1.png" />
    <meta property="article:published_time" content="2017-07-25T19:00:00.000Z" />
    <meta property="article:modified_time" content="2017-08-01T10:13:24.321Z" />
    <meta property="article:tag" content="nlp" />
    <meta property="article:tag" content="natural language processing" />
    <meta property="article:tag" content="deep learning" />
    <meta property="article:tag" content="machine learning" />
    
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Deep Learning for NLP Best Practices" />
    <meta name="twitter:description" content="A collection of best practices for Deep Learning for a wide array of Natural Language Processing tasks." />
    <meta name="twitter:url" content="u=http://ruder.io/deep-learning-nlp-best-practices/" />
    <meta name="twitter:image:src" content="u=http://ruder.io/content/images/2017/07/attention_bahdanau-1.png" />
    
    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Article",
    "publisher": "Sebastian Ruder",
    "author": {
        "@type": "Person",
        "name": "Sebastian Ruder",
        "url": "u=http://ruder.io/author/sebastian",
        "sameAs": null,
        "description": null
    },
    "headline": "Deep Learning for NLP Best Practices",
    "url": "u=http://ruder.io/deep-learning-nlp-best-practices/",
    "datePublished": "2017-07-25T19:00:00.000Z",
    "dateModified": "2017-08-01T10:13:24.321Z",
    "image": "u=http://ruder.io/content/images/2017/07/attention_bahdanau-1.png",
    "keywords": "nlp, natural language processing, deep learning, machine learning",
    "description": "A collection of best practices for Deep Learning for a wide array of Natural Language Processing tasks."
}
    </script>

    <meta name="generator" content="Ghost 0.7" />
    <link rel="alternate" type="application/rss+xml" title="Sebastian Ruder" href="http://ruder.io/rss/" />
    <script>
var open_button = '.nav-blog > a'
</script>
<script>
var profile_title = 'Sebastian Ruder';
</script>
<script>
var disqus_shortname = 'sebastianruder';
</script>
<script>
var profile_resume ='NLP PhD student';
</script>
<script>
var ga_id = 'UA-60512592-1';
</script>
  </head>
  <body class="post-template tag-nlp tag-natural-language-processing tag-deep-learning tag-machine-learning">
    <header id="menu-button" class="expanded">
      <a><i class="icon icon-list"></i></a>
    </header>
    <aside class="cover" style="background: url(../content/images/2017/05/imageedit_8_8459453433.jpg) center/cover no-repeat fixed">
  <div class="cover container">
    <div class="profile">
      <a id="avatar-link" title="link to homepage for Sebastian Ruder" href="http://ruder.io/#open">
        <img src="../content/images/2015/12/Seb_LinkedIn_Profile-.png" alt="Sebastian Ruder avatar" class="profile avatar rounded hvr-buzz-out" />
        <h1 id="profile-title">Sebastian Ruder</h1>
        <h3 id="profile-resume"></h3>
      </a>

      <hr class="divider long" />
      <p>I&#x27;m a PhD student in Natural Language Processing and a research scientist at AYLIEN. I blog about Machine Learning, Deep Learning, NLP, and startups.</p>
      <hr class="divider short" />
      <div class="navigation">
        <div class="profile contact">
          <nav class="navigation left">
  <ul class="links">
      <li class="nav-blog ">
        <a href="http://ruder.io/">Blog</a>
      </li>
      <li class="nav-about ">
        <a href="http://ruder.io/about/">About</a>
      </li>
      <li class="nav-papers ">
        <a href="http://ruder.io/publications/">Papers</a>
      </li>
      <li class="nav-news ">
        <a href="http://ruder.io/news">News</a>
      </li>
      <li class="nav-newsletter ">
        <a href="http://ruder.io/newsletter">Newsletter</a>
      </li>
  </ul>
</nav>

          
<nav class="navigation right">
  <ul class="social expanded">

  <!-- Twitter -->
  <li class="social item hvr-grow-rotate">
    <a rel="me" target="blank" href="http://twitter.com/seb_ruder" title="@seb_ruder on Twitter">
      <i class='icon icon-social-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>

  <!-- Linkedin -->
  <li class="social item hvr-grow-rotate">
    <a rel="me" target="blank" href="https://www.linkedin.com/in/sebastianruder" title="sebastianruder on LinkedIn">
      <i class='icon icon-social-linkedin'></i>
      <span class="label">Linkedin</span>
    </a>
  </li>

  <!-- Github -->
  <li class="social item hvr-grow-rotate">
    <a rel="me" target="blank" href="https://github.com/sebastianruder" title="sebastianruder on Github">
      <i class='icon icon-social-github'></i>
      <span class="label">Github</span>
    </a>
  </li>

  <!-- E-mail -->
  <li class="social item hvr-grow-rotate">
    <a rel="me" target="blank" href="mailto:sebastian@ruder.io" title="send me an email">
      <i class='icon icon-mail'></i>
      <span class="label">Email</span>
    </a>
  </li>

  <!-- RSS -->
  <li class="social item hvr-grow-rotate">
    <a href="../rss/index.html" title="Subscribe to RSS">
      <i class='icon icon-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  </ul>
</nav>
          <section class="icon icon-search" id="search-container">
  <hr class="divider short" />
  <form id="search-form" action="https://www.google.com/#q=site:u=http://ruder.io">
    <input type="text" name="search" placeholder="Deep Learning, NLP, ..." id="search-field" />
  </form>
</section>
        </div>
      </div>
    </div>
  </div>
</aside>
    <main>
      <section id="search-results"></section>
      <section class="content">
        

  <article class="post tag-nlp tag-natural-language-processing tag-deep-learning tag-machine-learning">
    <header>
      <div class="post meta">
        <time datetime="25 Jul 2017">25 Jul 2017</time>
        <span class="post tags">in <a href="../tag/nlp/index.html">nlp</a> <a href="../tag/natural-language-processing/index.html">natural language processing</a> <a href="../tag/deep-learning/index.html">deep learning</a> <a href="../tag/machine-learning/index.html">machine learning</a></span>


        <span class="post reading-time"> ~ <span></span> read.</span>
      </div>
      <a alt="Tweet 'Deep Learning for NLP Best Practices'" href="https://twitter.com/intent/tweet?text=Deep%20Learning%20for%20NLP%20Best%20Practices%20%C2%BB&amp;hashtags=nlp,natural language processing,deep learning,machine learning&amp;url=http://ruder.io/deep-learning-nlp-best-practices/">
        <img id="post-image" src="../content/images/2017/07/attention_bahdanau-1.png" alt="Deep Learning for NLP Best Practices">
        <h1 class="icon-reverse icon-social-twitter-post" id="post-title">Deep Learning for NLP Best Practices</h1>
      </a>
    </header>

    <div id="post-content" class="post tag-nlp tag-natural-language-processing tag-deep-learning tag-machine-learning">
      <p>Table of contents:</p>

<ul>
<li><a href="index.html#introduction">Introduction</a></li>
<li><a href="index.html#bestpractices">Best practices</a>
<ul><li><a href="index.html#wordembeddings">Word embeddings</a></li>
<li><a href="index.html#depth">Depth</a></li>
<li><a href="index.html#layerconnections">Layer connections</a></li>
<li><a href="index.html#dropout">Dropout</a></li>
<li><a href="index.html#multitasklearning">Multi-task learning</a></li>
<li><a href="index.html#attention">Attention</a></li>
<li><a href="index.html#optimization">Optimization</a></li>
<li><a href="index.html#ensembling">Ensembling</a></li>
<li><a href="index.html#hyperparameteroptimization">Hyperparameter optimization</a></li>
<li><a href="index.html#lstmtricks">LSTM tricks</a></li></ul></li>
<li><a href="index.html#taskspecificbestpractices">Task-specific best practices</a>
<ul><li><a href="index.html#classification">Classification</a></li>
<li><a href="index.html#sequencelabelling">Sequence labelling</a></li>
<li><a href="index.html#naturallanguagegeneration">Natural language generation</a></li>
<li><a href="index.html#neuralmachinetranslation">Neural machine translation</a></li></ul></li>
</ul>

<h1 id="introduction">Introduction</h1>

<p>This post is a collection of best practices for using neural networks in Natural Language Processing. It will be updated periodically as new insights become available and in order to keep track of our evolving understanding of Deep Learning for NLP.</p>

<p>There has been a <a href="https://twitter.com/IAugenstein/status/710837374473920512">running joke</a> in the NLP community that an LSTM with attention will yield state-of-the-art performance on any task. While this has been true over the course of the last two years, the NLP community is slowly moving away from this now standard baseline and towards more interesting models.</p>

<p>However, we as a community do not want to spend the next two years independently (re-)discovering the <em>next</em> LSTM with attention. We do not want to reinvent tricks or methods that have already been shown to work. While many existing Deep Learning libraries already encode best practices for working with neural networks in general, such as initialization schemes, many other details, particularly task or domain-specific considerations, are left to the practitioner.</p>

<p>This post is not meant to keep track of the state-of-the-art, but rather to collect best practices that are relevant for a wide range of tasks. In other words, rather than describing one particular architecture, this post aims to collect the features that underly successful architectures. While many of these features will be most useful for pushing the state-of-the-art, I hope that wider knowledge of them will lead to stronger evaluations, more meaningful comparison to baselines, and inspiration by shaping our intuition of what works.</p>

<p>I assume you are familiar with neural networks as applied to NLP (if not, I recommend Yoav Goldberg's <a href="https://www.jair.org/media/4992/live-4992-9623-jair.pdf">excellent primer</a> [<sup id="fnref:43"><a href="index.html#fn:43" rel="footnote">43</a></sup>]) and are interested in NLP in general or in a particular task. The main goal of this article is to get you up to speed with the relevant best practices so you can make meaningful contributions as soon as possible.</p>

<p>I will first give an overview of best practices that are relevant for most tasks. I will then outline practices that are relevant for the most common tasks, in particular classification, sequence labelling, natural language generation, and neural machine translation.</p>

<p><strong>Disclaimer:</strong> Treating something as <em>best practice</em> is notoriously difficult: Best according to what? What if there are better alternatives? This post is based on my (necessarily incomplete) understanding and experience. In the following, I will only discuss practices that have been reported to be beneficial independently by <em>at least</em> two different groups. I will try to give at least two references for each best practice.</p>

<h1 id="bestpractices">Best practices</h1>

<h2 id="wordembeddings">Word embeddings</h2>

<p>Word embeddings are arguably the most widely known best practice in the recent history of NLP. It is well-known that using pre-trained embeddings helps (Kim, 2014) [<sup id="fnref:12"><a href="index.html#fn:12" rel="footnote">12</a></sup>]. The optimal dimensionality of word embeddings is mostly task-dependent: a smaller dimensionality works better for more syntactic tasks such as named entity recognition (Melamud et al., 2016) [<sup id="fnref:44"><a href="index.html#fn:44" rel="footnote">44</a></sup>] or part-of-speech (POS) tagging (Plank et al., 2016) [<sup id="fnref:32"><a href="index.html#fn:32" rel="footnote">32</a></sup>], while a larger dimensionality is more useful for more semantic tasks such as sentiment analysis (Ruder et al., 2016) [<sup id="fnref:45"><a href="index.html#fn:45" rel="footnote">45</a></sup>].</p>

<h2 id="depth"> Depth</h2>

<p>While we will not reach the depths of computer vision for a while, neural networks in NLP have become progressively deeper. State-of-the-art approaches now regularly use deep Bi-LSTMs, typically consisting of 3-4 layers, e.g. for POS tagging (Plank et al., 2016) and semantic role labelling (He et al., 2017) [<sup id="fnref:33"><a href="index.html#fn:33" rel="footnote">33</a></sup>]. Models for some tasks can be even deeper, cf. Google's NMT model with 8 encoder and 8 decoder layers (Wu et al., 2016) [<sup id="fnref:20"><a href="index.html#fn:20" rel="footnote">20</a></sup>]. In most cases, however, performance improvements of making the model deeper than 2 layers are minimal (Reimers &amp; Gurevych, 2017) [<sup id="fnref:46"><a href="index.html#fn:46" rel="footnote">46</a></sup>].</p>

<p>These observations hold for most sequence tagging and structured prediction problems. For classification, deep or very deep models perform well only with character-level input and shallow word-level models are still the state-of-the-art (Zhang et al., 2015; Conneau et al., 2016; Le et al., 2017) [<sup id="fnref:28"><a href="index.html#fn:28" rel="footnote">28</a></sup>, <sup id="fnref:29"><a href="index.html#fn:29" rel="footnote">29</a></sup>, <sup id="fnref:30"><a href="index.html#fn:30" rel="footnote">30</a></sup>].</p>

<h2 id="layerconnections">Layer connections</h2>

<p>For training deep neural networks, some tricks are essential to avoid the vanishing gradient problem. Different layers and connections have been proposed. Here, we will discuss three: i) highway layers, ii) residual connections, and iii) dense connections.</p>

<p><strong>Highway layers</strong> &nbsp; Highway layers (Srivastava et al., 2015) [<sup id="fnref:1"><a href="index.html#fn:1" rel="footnote">1</a></sup>] are inspired by the gates of an LSTM. First let us assume a one-layer MLP, which applies an affine transformation followed by a non-linearity \(g\) to its input \(\mathbf{x}\): </p>

<p>\(\mathbf{h} = g(\mathbf{W}\mathbf{x} + \mathbf{b})\)</p>

<p>A highway layer then computes the following function instead:</p>

<p>\(\mathbf{h} = \mathbf{t} \odot g(\mathbf{W} \mathbf{x} + \mathbf{b}) + (1-\mathbf{t}) \odot \mathbf{x} \)</p>

<p>where \(\odot\) is elementwise multiplication, \(\mathbf{t} = \sigma(\mathbf{W}_T \mathbf{x} + \mathbf{b}_T)\) is called the <em>transform</em> gate, and \((1-\mathbf{t})\) is called the <em>carry</em> gate. As we can see, highway layers are similar to the gates of an LSTM in that they adaptively <em>carry</em> some dimensions of the input directly to the output. </p>

<p>Highway layers have been used pre-dominantly to achieve state-of-the-art results for language modelling (Kim et al., 2016; Jozefowicz et al., 2016; Zilly et al., 2017) [<sup id="fnref:2"><a href="index.html#fn:2" rel="footnote">2</a></sup>, <sup id="fnref:3"><a href="index.html#fn:3" rel="footnote">3</a></sup>, <sup id="fnref:4"><a href="index.html#fn:4" rel="footnote">4</a></sup>], but have also been used for other tasks such as speech recognition (Zhang et al., 2016) [<sup id="fnref:5"><a href="index.html#fn:5" rel="footnote">5</a></sup>]. <a href="http://people.idsia.ch/~rupesh/very_deep_learning/">Sristava's page</a> contains more information and code regarding highway layers.</p>

<p><strong>Residual connections</strong> &nbsp; Residual connections (He et al., 2016) [<sup id="fnref:6"><a href="index.html#fn:6" rel="footnote">6</a></sup>] have been first proposed for computer vision and were the main factor for winning ImageNet 2016. Residual connections are even more straightforward than highway layers and learn the following function:</p>

<p>\(\mathbf{h} = g(\mathbf{W}\mathbf{x} + \mathbf{b}) + \mathbf{x}\) </p>

<p>which simply adds the input of the current layer to its output via a short-cut connection. This simple modification mitigates the vanishing gradient problem, as the model can default to using the identity function if the layer is not beneficial.</p>

<p><strong>Dense connections</strong> &nbsp; Rather than just adding layers from each layer to the next, dense connections (Huang et al., 2017) [<sup id="fnref:7"><a href="index.html#fn:7" rel="footnote">7</a></sup>] (best paper award at CVPR 2017) add direct connections from each layer to all subsequent layers. Let us augment the layer output \(h\) and layer input \(x\) with indices \(l\) indicating the current layer. Dense connections then feed the concatenated output from all previous layers as input to the current layer:</p>

<p>\(\mathbf{h}^l = g(\mathbf{W}[\mathbf{x}^1; \ldots; \mathbf{x}^l] + \mathbf{b})\)</p>

<p>where \([\cdot; \cdot]\) represents concatenation. Dense connections have been successfully used in computer vision. They have also found to be useful for Multi-Task Learning of different NLP tasks (Ruder et al., 2017) [<sup id="fnref:49"><a href="index.html#fn:49" rel="footnote">49</a></sup>], while a residual variant that uses summation has been shown to consistently outperform residual connections for neural machine translation (Britz et al., 2017) [<sup id="fnref:27"><a href="index.html#fn:27" rel="footnote">27</a></sup>].</p>

<h2 id="dropout">Dropout</h2>

<p>While batch normalisation in computer vision has made other regularizers obsolete in most applications, dropout (Srivasta et al., 2014) [<sup id="fnref:8"><a href="index.html#fn:8" rel="footnote">8</a></sup>] is still the go-to regularizer for deep neural networks in NLP. A dropout rate of 0.5 has been shown to be effective in most scenarios (Kim, 2014). In recent years, variations of dropout such as adaptive (Ba &amp; Frey, 2013) [<sup id="fnref:9"><a href="index.html#fn:9" rel="footnote">9</a></sup>] and evolutional dropout (Li et al., 2016) [<sup id="fnref:10"><a href="index.html#fn:10" rel="footnote">10</a></sup>] have been proposed, but none of these have found wide adoption in the community. The main problem hindering dropout in NLP has been that it could not be applied to recurrent connections, as the aggregating dropout masks would effectively zero out embeddings over time.</p>

<p><strong>Recurrent dropout</strong> &nbsp; Recurrent dropout (Gal &amp; Ghahramani, 2016) [<sup id="fnref:11"><a href="index.html#fn:11" rel="footnote">11</a></sup>] addresses this issue by applying the same dropout mask across timesteps at layer \(l\). This avoids amplifying the dropout noise along the sequence and leads to effective regularization for sequence models. Recurrent dropout has been used for instance to achieve state-of-the-art results in semantic role labelling (He et al., 2017) and language modelling (Melis et al., 2017) [<sup id="fnref:34"><a href="index.html#fn:34" rel="footnote">34</a></sup>].</p>

<h2 id="multitasklearning">Multi-task learning</h2>

<p>If additional data is available, multi-task learning (MTL) can often be used to improve performance on the target task. Have a look <a href="http://ruder.io/multi-task/index.html">this blog post</a> for more information on MTL.</p>

<p><strong>Auxiliary objectives</strong> &nbsp; We can often find auxiliary objectives that are useful for the task we care about (Ruder, 2017) [<sup id="fnref:13"><a href="index.html#fn:13" rel="footnote">13</a></sup>]. While we can already predict surrounding words in order to pre-train word embeddings (Mikolov et al., 2013), we can also use this as an auxiliary objective during training (Rei, 2017) [<sup id="fnref:35"><a href="index.html#fn:35" rel="footnote">35</a></sup>]. A similar objective has also been used by  (Ramachandran et al., 2016) [<sup id="fnref:36"><a href="index.html#fn:36" rel="footnote">36</a></sup>] for sequence-to-sequence models.</p>

<p><strong>Task-specific layers</strong> &nbsp; While the standard approach to MTL for NLP is hard parameter sharing, it is beneficial to allow the model to learn task-specific layers. This can be done by placing the output layer of one task at a lower level (Søgaard &amp; Goldberg, 2016) [<sup id="fnref:47"><a href="index.html#fn:47" rel="footnote">47</a></sup>]. Another way is to induce private and shared subspaces (Liu et al., 2017; Ruder et al., 2017) [<sup id="fnref:48"><a href="index.html#fn:48" rel="footnote">48</a></sup>, <sup id="fnref:49"><a href="index.html#fn:49" rel="footnote">49</a></sup>].</p>

<h2 id="attention"> Attention</h2>

<p>Attention is most commonly used in sequence-to-sequence models to attend to encoder states, but can also be used in any sequence model to look back at past states. Using attention, we obtain a context vector \(\mathbf{c}_i\) based on hidden states \(\mathbf{s}_1, \ldots, \mathbf{s}_m\) that can be used together with the current hidden state \(\mathbf{h}_i\) for prediction. The context vector \(\mathbf{c}_i\) at position is calculated as an average of the previous states weighted with the attention scores \(\mathbf{a}_i\):</p>

<p>\(\begin{align}\begin{split}
\mathbf{c}_i &amp;= \sum\limits_j a_{ij}\mathbf{s}_j\\
\mathbf{a}_i &amp;= \text{softmax}(f_{att}(\mathbf{h}_i, \mathbf{s}_j))
\end{split}\end{align}\)</p>

<p>The attention function \(f_{att}(\mathbf{h}_i, \mathbf{s}_j)\) calculates an unnormalized alignment score between the current hidden state \(\mathbf{h}_i\) and the previous hidden state \(\mathbf{s}_j\). In the following, we will discuss four attention variants: i) additive attention, ii) multiplicative attention, iii) self-attention, and iv) key-value attention.</p>

<p><strong>Additive attention</strong> &nbsp; The original attention mechanism (Bahdanau et al., 2015) [<sup id="fnref:15"><a href="index.html#fn:15" rel="footnote">15</a></sup>] uses a one-hidden layer feed-forward network to calculate the attention alignment:</p>

<p>\(f_{att}(\mathbf{h}_i, \mathbf{s}_j) = \mathbf{v}_a{}^\top \text{tanh}(\mathbf{W}_a[\mathbf{h}_i; \mathbf{s}_j]) \)</p>

<p>where \(\mathbf{v}_a\) and \(\mathbf{W}_a\) are learned attention parameters. Analogously, we can also use matrices \(\mathbf{W}_1\) and \(\mathbf{W}_2\) to learn separate transformations for \(\mathbf{h}_i\) and \(\mathbf{s}_j\) respectively, which are then summed:</p>

<p>\(f_{att}(\mathbf{h}_i, \mathbf{s}_j) = \mathbf{v}_a{}^\top \text{tanh}(\mathbf{W}_1 \mathbf{h}_i + \mathbf{W}_2 \mathbf{s}_j) \)</p>

<p><strong>Multiplicative attention</strong> &nbsp; Multiplicative attention (Luong et al., 2015) [<sup id="fnref:16"><a href="index.html#fn:16" rel="footnote">16</a></sup>] simplifies the attention operation by calculating the following function:</p>

<p>\(f_{att}(h_i, s_j) = h_i^\top \mathbf{W}_a s_j \)</p>

<p>Additive and multiplicative attention are similar in complexity, although multiplicative attention is faster and more space-efficient in practice as it can be implemented more efficiently using matrix multiplication. Both variants perform similar for small dimensionality \(d_h\) of the decoder states, but additive attention performs better for larger dimensions. One way to mitigate this is to scale \(f_{att}(\mathbf{h}_i, \mathbf{s}_j)\) by \(1 / \sqrt{d_h}\) (Vaswani et al., 2017) [<sup id="fnref:17"><a href="index.html#fn:17" rel="footnote">17</a></sup>]. </p>

<p>Attention cannot only be used to attend to encoder or previous hidden states, but also to obtain a distribution over other features, such as the word embeddings of a text as used for reading comprehension (Kadlec et al., 2017) [<sup id="fnref:37"><a href="index.html#fn:37" rel="footnote">37</a></sup>]. However, attention is not directly applicable to classification tasks that do not require additional information, such as sentiment analysis. In such models, the final hidden state of an LSTM or an aggregation function such as max pooling or averaging is often used to obtain a sentence representation. </p>

<p><strong>Self-attention</strong> &nbsp; Without any additional information, however, we can still extract relevant aspects from the sentence by allowing it to attend to itself using self-attention (Lin et al., 2017) [<sup id="fnref:18"><a href="index.html#fn:18" rel="footnote">18</a></sup>]. Self-attention, also called intra-attention has been used successfully in a variety of tasks including reading comprehension (Cheng et al., 2016) [<sup id="fnref:38"><a href="index.html#fn:38" rel="footnote">38</a></sup>], textual entailment (Parikh et al., 2016) [<sup id="fnref:39"><a href="index.html#fn:39" rel="footnote">39</a></sup>], and abstractive summarization (Paulus et al., 2017) [<sup id="fnref:40"><a href="index.html#fn:40" rel="footnote">40</a></sup>].</p>

<p>We can simplify additive attention to compute the unnormalized alignment score for each hidden state \(\mathbf{h}_i\):</p>

<p>\(f_{att}(\mathbf{h}_i) = \mathbf{v}_a{}^\top \text{tanh}(\mathbf{W}_a \mathbf{h}_i) \)</p>

<p>In matrix form, for hidden states \(\mathbf{H} = \mathbf{h}_1, \ldots, \mathbf{h}_n\) we can calculate the attention vector \(\mathbf{a}\) and the final sentence representation \(\mathbf{c}\) as follows:</p>

<p>\(\begin{align}\begin{split}
\mathbf{a} &amp;= \text{softmax}(\mathbf{v}_a \text{tanh}(\mathbf{W}_a \mathbf{H}^\top))\\
\mathbf{c} &amp; = \mathbf{H} \mathbf{a}^\top
\end{split}\end{align}\)</p>

<p>Rather than only extracting one vector, we can perform several hops of attention by using a matrix \(\mathbf{V}_a\) instead of \(\mathbf{v}_a\), which allows us to extract an attention matrix \(\mathbf{A}\): </p>

<p>\(\begin{align}\begin{split}
\mathbf{A} &amp;= \text{softmax}(\mathbf{V}_a \text{tanh}(\mathbf{W}_a \mathbf{H}^\top))\\
\mathbf{C} &amp; = \mathbf{A} \mathbf{H}
\end{split}\end{align}\)</p>

<p>In practice, we enforce the following orthogonality constraint to penalize redundancy and encourage diversity in the attention vectors in the form of the squared Frobenius norm:</p>

<p>\(\Omega = \|(\mathbf{A}\mathbf{A}^\top - \mathbf{I} \|^2_F \)</p>

<p>A similar multi-head attention is also used by Vaswani et al. (2017).</p>

<p><strong>Key-value attention</strong> &nbsp; Finally, key-value attention (Daniluk et al., 2017) [<sup id="fnref:19"><a href="index.html#fn:19" rel="footnote">19</a></sup>] is a recent attention variant that separates form from function by keeping separate vectors for the attention calculation. It has also been found useful for different document modelling tasks (Liu &amp; Lapata, 2017) [<sup id="fnref:41"><a href="index.html#fn:41" rel="footnote">41</a></sup>]. Specifically, key-value attention splits each hidden vector \(\mathbf{h}_i\) into a key \(\mathbf{k}_i\) and a value \(\mathbf{v}_i\): \([\mathbf{k}_i; \mathbf{v}_i] = \mathbf{h}_i\). The keys are used for calculating the attention distribution \(\mathbf{a}_i\) using additive attention:</p>

<p>\(\mathbf{a}_i = \text{softmax}(\mathbf{v}_a{}^\top \text{tanh}(\mathbf{W}_1 [\mathbf{k}_{i-L}; \ldots; \mathbf{k}_{i-1}] + (\mathbf{W}_2 \mathbf{k}_i)\mathbf{1}^\top)) \)</p>

<p>where \(L\) is the length of the attention window and \(\mathbf{1}\) is a vector of ones. The  values are then used to obtain the context representation \(\mathbf{c}_i\):</p>

<p>\(\mathbf{c}_i = [\mathbf{v}_{i-L}; \ldots; \mathbf{v}_{i-1}] \mathbf{a}^\top\) </p>

<p>The context \(\mathbf{c}_i\) is used together with the current value \(\mathbf{v}_i\) for prediction.</p>

<h2 id="optimization"> Optimization</h2>

<p>The optimization algorithm and scheme is often one of the parts of the model that is used as-is and treated as a black-box. Sometimes, even slight changes to the algorithm, e.g. reducing the \(\beta_2\) value in Adam (Dozat &amp; Manning, 2017) [<sup id="fnref:50"><a href="index.html#fn:50" rel="footnote">50</a></sup>] can make a large difference to the optimization behaviour.</p>

<p><strong>Optimization algorithm</strong> &nbsp; Adam (Kingma &amp; Ba, 2015) [<sup id="fnref:21"><a href="index.html#fn:21" rel="footnote">21</a></sup>] is one of the most popular and widely used optimization algorithms and often the go-to optimizer for NLP researchers. It is often thought that Adam clearly outperforms vanilla stochastic gradient descent (SGD). However, while it converges much faster than SGD, it has been observed that SGD with learning rate annealing slightly outperforms Adam (Wu et al., 2016). Recent work furthermore shows that SGD with properly tuned momentum outperforms Adam (Zhang et al., 2017) [<sup id="fnref:42"><a href="index.html#fn:42" rel="footnote">42</a></sup>]. </p>

<p><strong>Optimization scheme</strong> &nbsp; While Adam internally tunes the learning rate for every parameter (Ruder, 2016) [<sup id="fnref:22"><a href="index.html#fn:22" rel="footnote">22</a></sup>], we can explicitly use SGD-style annealing with Adam. In particular, we can perform learning rate annealing with restarts: We set a learning rate and train the model until convergence. We then halve the learning rate and restart by loading the previous best model. In Adam's case, this causes the optimizer to forget its per-parameter learning rates and start fresh. Denkowski &amp; Neubig (2017) [<sup id="fnref:23"><a href="index.html#fn:23" rel="footnote">23</a></sup>] show that Adam with 2 restarts and learning rate annealing is faster and performs better than SGD with annealing.</p>

<h2 id="ensembling">Ensembling</h2>

<p>Combining multiple models into an ensemble by averaging their predictions is a proven strategy to improve model performance. While predicting with an ensemble is expensive at test time, recent advances in distillation allow us to compress an expensive ensemble into a much smaller model (Hinton et al., 2015; Kuncoro et al., 2016; Kim &amp; Rush, 2016) [<sup id="fnref:24"><a href="index.html#fn:24" rel="footnote">24</a></sup>, <sup id="fnref:25"><a href="index.html#fn:25" rel="footnote">25</a></sup>, <sup id="fnref:26"><a href="index.html#fn:26" rel="footnote">26</a></sup>].</p>

<p>Ensembling is an important way to ensure that results are still reliable if the diversity of the evaluated models increases (Denkowski &amp; Neubig, 2017). While ensembling different checkpoints of a model has been shown to be effective (Jean et al., 2015; Sennrich et al., 2016) [<sup id="fnref:51"><a href="index.html#fn:51" rel="footnote">51</a></sup>, <sup id="fnref:52"><a href="index.html#fn:52" rel="footnote">52</a></sup>], it comes at the cost of model diversity. Cyclical learning rates can help to mitigate this effect (Huang et al., 2017) [<sup id="fnref:53"><a href="index.html#fn:53" rel="footnote">53</a></sup>]. However, if resources are available, we prefer to ensemble multiple independently trained models to maximize model diversity.</p>

<h2 id="hyperparameteroptimization">Hyperparameter optimization</h2>

<p>Rather than pre-defining or using off-the-shelf hyperparameters, simply tuning the hyperparameters of our model can yield significant improvements over baselines. Recent advances in Bayesian Optimization have made it an ideal tool for the black-box optimization of hyperparameters in neural networks (Snoek et al., 2012) [<sup id="fnref:56"><a href="index.html#fn:56" rel="footnote">56</a></sup>] and far more efficient than the widely used grid search. Automatic tuning of hyperparameters of an LSTM has led to state-of-the-art results in language modeling, outperforming models that are far more complex (Melis et al., 2017).</p>

<h2 id="lstmtricks">LSTM tricks</h2>

<p><strong>Learning the initial state</strong> &nbsp; We generally initialize the initial LSTM states with a \(0\) vector. Instead of fixing the initial state, we can learn it like any other parameter, which can improve performance and is also <a href="https://www.cs.toronto.edu/~hinton/csc2535/notes/lec10new.pdf">recommended by Hinton</a>. Refer to <a href="https://r2rt.com/non-zero-initial-states-for-recurrent-neural-networks.html">this blog post</a> for a Tensorflow implementation.</p>

<p><strong>Tying input and output embeddings</strong> &nbsp; Input and output embeddings account for the largest number of parameters in the LSTM model. If the LSTM predicts words as in language modelling, input and output parameters can be shared (Inan et al., 2016; Press &amp; Wolf, 2017) [<sup id="fnref:54"><a href="index.html#fn:54" rel="footnote">54</a></sup>, <sup id="fnref:55"><a href="index.html#fn:55" rel="footnote">55</a></sup>]. This is particularly useful on small datasets that do not allow to learn a large number of parameters.</p>

<p><strong>Gradient norm clipping</strong> &nbsp; One way to decrease the risk of exploding gradients is to clip their maximum value (Mikolov, 2012) [<sup id="fnref:57"><a href="index.html#fn:57" rel="footnote">57</a></sup>]. This, however, does not improve performance consistently (Reimers &amp; Gurevych, 2017). Rather than clipping each gradient independently, clipping the global norm of the gradient (Pascanu et al., 2013) [<sup id="fnref:58"><a href="index.html#fn:58" rel="footnote">58</a></sup>] yields more significant improvements (a Tensorflow implementation can be found <a href="https://stackoverflow.com/questions/36498127/how-to-effectively-apply-gradient-clipping-in-tensor-flow">here</a>).</p>

<p><strong>Down-projection</strong> &nbsp; To reduce the number of output parameters further, the hidden state of the LSTM can be projected to a smaller size. This is useful particularly for tasks with a large number of outputs, such as language modelling (Melis et al., 2017).</p>

<h1 id="taskspecificbestpractices">Task-specific best practices</h1>

<p>In the following, we will discuss task-specific best practices. Most of these perform best for a particular type of task. Some of them might still be applied to other tasks, but should be validated before. We will discuss the following tasks: classification, sequence labelling, natural language generation (NLG), and -- as a special case of NLG -- neural machine translation.</p>

<h2 id="classification">Classification</h2>

<p>More so than for sequence tasks, where CNNs have only recently found application due to more efficient convolutional operations, CNNs have been popular for classification tasks in NLP. The following best practices relate to CNNs and capture some of their optimal hyperparameter choices.</p>

<p><strong>CNN filters</strong> &nbsp; Combining filter sizes near the optimal filter size, e.g. (3,4,5) performs best (Kim, 2014; Kim et al., 2016). The optimal number of feature maps is in the range of 50-600 (Zhang &amp; Wallace, 2015) [<sup id="fnref:59"><a href="index.html#fn:59" rel="footnote">59</a></sup>].</p>

<p><strong>Aggregation function</strong> &nbsp; 1-max-pooling outperforms average-pooling and \(k\)-max pooling (Zhang &amp; Wallace, 2015). </p>

<h2 id="sequencelabelling">Sequence labelling</h2>

<p>Sequence labelling is ubiquitous in NLP. While many of the existing best practices are with regard to a particular part of the model architecture, the following guidelines discuss choices for the model's output and prediction stage.</p>

<p><strong>Tagging scheme</strong> &nbsp; For some tasks, which can assign labels to segments of texts, different tagging schemes are possible. These are: <em>BIO</em>, which marks the first token in a segment with a <em>B-</em> tag, all remaining tokens in the span with an <em>I-</em>tag, and tokens outside of segments with an <em>O-</em> tag; <em>IOB</em>, which is similar to BIO, but only uses <em>B-</em> if the previous token is of the same class but not part of the segment; and <em>IOBES</em>, which in addition distinguishes between single-token entities (<em>S-</em>) and the last token in a segment (<em>E-</em>). Using IOBES and BIO yield similar performance (Lample et al., 2017) </p>

<p><strong>CRF output layer</strong> &nbsp; If there are any dependencies between outputs, such as in named entity recognition the final softmax layer can be replaced with a linear-chain conditional random field (CRF). This has been shown to yield consistent improvements for tasks that require the modelling of constraints (Huang et al., 2015; Max &amp; Hovy, 2016; Lample et al., 2016) [<sup id="fnref:60"><a href="index.html#fn:60" rel="footnote">60</a></sup>, <sup id="fnref:61"><a href="index.html#fn:61" rel="footnote">61</a></sup>, <sup id="fnref:62"><a href="index.html#fn:62" rel="footnote">62</a></sup>].</p>

<p><strong>Constrained decoding</strong> &nbsp; Rather than using a CRF output layer, constrained decoding can be used as an alternative approach to reject erroneous sequences, i.e. such that do not produce valid BIO transitions (He et al., 2017). Constrained decoding has the advantage that arbitrary constraints can be enforced this way, e.g. task-specific or syntactic constraints.</p>

<h2 id="naturallanguagegeneration">Natural language generation</h2>

<p>Most of the existing best practices can be applied to natural language generation (NLG). In fact, many of the tips presented so far stem from advances in language modelling, the most prototypical NLP task. </p>

<p><strong>Modelling coverage</strong> &nbsp; Repetition is a big problem in many NLG tasks as current models do not have a good way of remembering what outputs they already produced. Modelling coverage explicitly in the model is a good way of addressing this issue. A checklist can be used if it is known in advances, which entities should be mentioned in the output, e.g. ingredients in recipes (Kiddon et al., 2016) [<sup id="fnref:63"><a href="index.html#fn:63" rel="footnote">63</a></sup>]. If attention is used, we can keep track of a coverage vector \(\mathbf{c}_i\), which is the sum of attention distributions \(\mathbf{a}_t\) over previous time steps (Tu et al., 2016; See et al., 2017) [<sup id="fnref:64"><a href="index.html#fn:64" rel="footnote">64</a></sup>, <sup id="fnref:65"><a href="index.html#fn:65" rel="footnote">65</a></sup>]:</p>

<p>\(\mathbf{c}_i = \sum\limits^{i-1}_{t=1} \mathbf{a}_t \)</p>

<p>This vector captures how much attention we have paid to all words in the source. We can now condition additive attention additionally on this coverage vector in order to encourage our model not to attend to the same words repeatedly:</p>

<p>\(f_{att}(\mathbf{h}_i,\mathbf{s}_j,\mathbf{c}_i) = \mathbf{v}_a{}^\top \text{tanh}(\mathbf{W}_1 \mathbf{h}_i + \mathbf{W}_2 \mathbf{s}_j + \mathbf{W}_3 \mathbf{c}_i )\)</p>

<p>In addition, we can add an auxiliary loss that captures the task-specific attention behaviour that we would like to elicit: For NMT, we would like to have a roughly one-to-one alignment; we thus penalize the model if the final coverage vector is more or less than one at every index (Tu et al., 2016). For summarization, we only want to penalize the model if it repeatedly attends to the same location (See et al., 2017). </p>

<h2 id="neuralmachinetranslation">Neural machine translation</h2>

<p>While neural machine translation (NMT) is an instance of NLG, NMT receives so much attention that many methods have been developed specifically for the task. Similarly, many best practices or hyperparameter choices apply exclusively to it.</p>

<p><strong>Embedding dimensionality</strong> &nbsp; 2048-dimensional embeddings yield the best performance, but only do so by a small margin. Even 128-dimensional embeddings perform surprisingly well and converge almost twice as quickly (Britz et al., 2017).</p>

<p><strong>Encoder and decoder depth</strong> &nbsp; The encoder does not need to be deeper than \(2-4\) layers. Deeper models outperform shallower ones, but more than \(4\) layers is not necessary for the decoder (Britz et al., 2017).</p>

<p><strong>Directionality</strong> &nbsp; Bidirectional encoders outperform unidirectional ones by a small margin. 
Sutskever et al., (2014) [<sup id="fnref:67"><a href="index.html#fn:67" rel="footnote">67</a></sup>] proposed to reverse the source sequence to reduce the number of long-term dependencies. Reversing the source sequence in unidirectional encoders outperforms its non-reversed counter-part (Britz et al., 2017).</p>

<p><strong>Beam search strategy</strong> &nbsp; Medium beam sizes around \(10\) with length normalization penalty of \(1.0\) (Wu et al., 2016) yield the best performance (Britz et al., 2017).</p>

<p><strong>Sub-word translation</strong> &nbsp; Senrich et al. (2016) [<sup id="fnref:66"><a href="index.html#fn:66" rel="footnote">66</a></sup>] proposed to split words into sub-words based on a byte-pair encoding (BPE). BPE iteratively merges frequent symbol pairs, which eventually results in frequent character n-grams being merged into a single symbol, thereby effectively eliminating out-of-vocabulary-words. While it was originally meant to handle rare words, a model with sub-word units outperforms full-word systems across the board, with 32,000 being an effective vocabulary size for sub-word units (Denkowski &amp; Neubig, 2017).</p>

<h1 id="conclusion">Conclusion</h1>

<p>I hope this post was helpful in kick-starting your learning of a new NLP task. Even if you have already been familiar with most of these, I hope that you still learnt something new or refreshed your knowledge of useful tips.</p>

<p>I am sure that I have forgotten many best practices that deserve to be on this list. Similarly, there are many tasks such as parsing, information extraction, etc., which I do not know enough about to give recommendations. If you have a best practice that should be on this list, do let me know in the comments below. Please provide at least one reference and your handle for attribution. If this gets very collaborative, I might open a GitHub repository rather than collecting feedback here (I won't be able to accept PRs submitted directly to the generated HTML source of this article).</p>

<h1 id="references">References</h1>

<div class="footnotes"><ol><li class="footnote" id="fn:1"><p>Srivastava, R. K., Greff, K., &amp; Schmidhuber, J. (2015). Training Very Deep Networks. In Advances in Neural Information Processing Systems. <a href="index.html#fnref:1" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:2"><p>Kim, Y., Jernite, Y., Sontag, D., &amp; Rush, A. M. (2016). Character-Aware Neural Language Models. AAAI. Retrieved from <a href="http://arxiv.org/abs/1508.06615">http://arxiv.org/abs/1508.06615</a> <a href="index.html#fnref:2" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:3"><p>Jozefowicz, R., Vinyals, O., Schuster, M., Shazeer, N., &amp; Wu, Y. (2016). Exploring the Limits of Language Modeling. arXiv Preprint arXiv:1602.02410. Retrieved from <a href="http://arxiv.org/abs/1602.02410">http://arxiv.org/abs/1602.02410</a> <a href="index.html#fnref:3" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:4"><p>Zilly, J. G., Srivastava, R. K., Koutnik, J., &amp; Schmidhuber, J. (2017). Recurrent Highway Networks. In International Conference on Machine Learning (ICML 2017). <a href="index.html#fnref:4" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:5"><p>Zhang, Y., Chen, G., Yu, D., Yao, K., Kudanpur, S., &amp; Glass, J. (2016). Highway Long Short-Term Memory RNNS for Distant Speech Recognition. In 2016 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP). <a href="index.html#fnref:5" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:6"><p>He, K., Zhang, X., Ren, S., &amp; Sun, J. (2016). Deep Residual Learning for Image Recognition. In CVPR. <a href="index.html#fnref:6" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:7"><p>Huang, G., Weinberger, K. Q., &amp; Maaten, L. Van Der. (2016). Densely Connected Convolutional Networks. CVPR 2017. <a href="index.html#fnref:7" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:8"><p>Srivastava, N., Hinton, G., Krizhevsky, A., Sutskever, I., &amp; Salakhutdinov, R. (2014). Dropout: A Simple Way to Prevent Neural Networks from Overfitting. Journal of Machine Learning Research, 15, 1929–1958. <a href="http://www.cs.cmu.edu/~rsalakhu/papers/srivastava14a.pdf">http://www.cs.cmu.edu/~rsalakhu/papers/srivastava14a.pdf</a> <a href="index.html#fnref:8" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:9"><p>Ba, J., &amp; Frey, B. (2013). Adaptive dropout for training deep neural networks. In Advances in Neural Information Processing Systems. Retrieved from file:///Files/A5/A51D0755-5CEF-4772-942D-C5B8157FBE5E.pdf <a href="index.html#fnref:9" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:10"><p>Li, Z., Gong, B., &amp; Yang, T. (2016). Improved Dropout for Shallow and Deep Learning. In Advances in Neural Information Processing Systems 29 (NIPS 2016). Retrieved from <a href="http://arxiv.org/abs/1602.02220">http://arxiv.org/abs/1602.02220</a> <a href="index.html#fnref:10" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:11"><p>Gal, Y., &amp; Ghahramani, Z. (2016). A Theoretically Grounded Application of Dropout in Recurrent Neural Networks. In Advances in Neural Information Processing Systems. Retrieved from <a href="http://arxiv.org/abs/1512.05287">http://arxiv.org/abs/1512.05287</a> <a href="index.html#fnref:11" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:12"><p>Kim, Y. (2014). Convolutional Neural Networks for Sentence Classification. Proceedings of the Conference on Empirical Methods in Natural Language Processing, 1746–1751. Retrieved from <a href="http://arxiv.org/abs/1408.5882">http://arxiv.org/abs/1408.5882</a> <a href="index.html#fnref:12" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:13"><p>Ruder, S. (2017). An Overview of Multi-Task Learning in Deep Neural Networks. In arXiv preprint arXiv:1706.05098. <a href="index.html#fnref:13" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:14"><p>Semi-supervised Multitask Learning for Sequence Labeling. In Proceedings of ACL 2017. <a href="index.html#fnref:14" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:15"><p>Bahdanau, D., Cho, K., &amp; Bengio, Y.. Neural Machine Translation by Jointly Learning to Align and Translate. ICLR 2015. <a href="https://doi.org/10.1146/annurev.neuro.26.041002.131047">https://doi.org/10.1146/annurev.neuro.26.041002.131047</a> <a href="index.html#fnref:15" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:16"><p>Luong, M.-T., Pham, H., &amp; Manning, C. D. (2015). Effective Approaches to Attention-based Neural Machine Translation. EMNLP 2015. Retrieved from <a href="http://arxiv.org/abs/1508.04025">http://arxiv.org/abs/1508.04025</a> <a href="index.html#fnref:16" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:17"><p>Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., … Polosukhin, I. (2017). Attention Is All You Need. arXiv Preprint arXiv:1706.03762. <a href="index.html#fnref:17" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:18"><p>Lin, Z., Feng, M., Santos, C. N. dos, Yu, M., Xiang, B., Zhou, B., &amp; Bengio, Y. (2017). A Structured Self-Attentive Sentence Embedding. In ICLR 2017. <a href="index.html#fnref:18" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:19"><p>Daniluk, M., Rockt, T., Welbl, J., &amp; Riedel, S. (2017). Frustratingly Short Attention Spans in Neural Language Modeling. In ICLR 2017.  <a href="index.html#fnref:19" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:20"><p>Wu, Y., Schuster, M., Chen, Z., Le, Q. V, Norouzi, M., Macherey, W., … Dean, J. (2016). Google’s Neural Machine Translation System: Bridging the Gap between Human and Machine Translation. arXiv Preprint arXiv:1609.08144. <a href="index.html#fnref:20" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:21"><p>Kingma, D. P., &amp; Ba, J. L. (2015). Adam: a Method for Stochastic Optimization. International Conference on Learning Representations. <a href="index.html#fnref:21" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:22"><p>Ruder, S. (2016). An overview of gradient descent optimization. arXiv Preprint arXiv:1609.04747. <a href="index.html#fnref:22" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:23"><p>Denkowski, M., &amp; Neubig, G. (2017). Stronger Baselines for Trustable Results in Neural Machine Translation. <a href="index.html#fnref:23" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:24"><p>Hinton, G., Vinyals, O., &amp; Dean, J. (2015). Distilling the Knowledge in a Neural Network. arXiv Preprint arXiv:1503.02531. <a href="https://doi.org/10.1063/1.4931082">https://doi.org/10.1063/1.4931082</a> <a href="index.html#fnref:24" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:25"><p>Kuncoro, A., Ballesteros, M., Kong, L., Dyer, C., &amp; Smith, N. A. (2016). Distilling an Ensemble of Greedy Dependency Parsers into One MST Parser. Empirical Methods in Natural Language Processing. <a href="index.html#fnref:25" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:26"><p>Kim, Y., &amp; Rush, A. M. (2016). Sequence-Level Knowledge Distillation. Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing (EMNLP-16). <a href="index.html#fnref:26" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:27"><p>Britz, D., Goldie, A., Luong, T., &amp; Le, Q. (2017). Massive Exploration of Neural Machine Translation Architectures. In arXiv preprint arXiv:1703.03906. <a href="index.html#fnref:27" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:28"><p>Zhang, X., Zhao, J., &amp; LeCun, Y. (2015). Character-level Convolutional Networks for Text Classification. Advances in Neural Information Processing Systems, 649–657. Retrieved from <a href="http://arxiv.org/abs/1509.01626">http://arxiv.org/abs/1509.01626</a> <a href="index.html#fnref:28" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:29"><p>Conneau, A., Schwenk, H., Barrault, L., &amp; Lecun, Y. (2016). Very Deep Convolutional Networks for Natural Language Processing. arXiv Preprint arXiv:1606.01781. Retrieved from <a href="http://arxiv.org/abs/1606.01781">http://arxiv.org/abs/1606.01781</a> <a href="index.html#fnref:29" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:30"><p>Le, H. T., Cerisara, C., &amp; Denis, A. (2017). Do Convolutional Networks need to be Deep for Text Classification ? In arXiv preprint arXiv:1707.04108. <a href="index.html#fnref:30" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:31"><p>Wu, Y., Schuster, M., Chen, Z., Le, Q. V, Norouzi, M., Macherey, W., … Dean, J. (2016). Google’s Neural Machine Translation System: Bridging the Gap between Human and Machine Translation. arXiv Preprint arXiv:1609.08144. <a href="index.html#fnref:31" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:32"><p>Plank, B., Søgaard, A., &amp; Goldberg, Y. (2016). Multilingual Part-of-Speech Tagging with Bidirectional Long Short-Term Memory Models and Auxiliary Loss. In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics. <a href="index.html#fnref:32" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:33"><p>He, L., Lee, K., Lewis, M., &amp; Zettlemoyer, L. (2017). Deep Semantic Role Labeling: What Works and What’s Next. ACL. <a href="index.html#fnref:33" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:34"><p>Melis, G., Dyer, C., &amp; Blunsom, P. (2017). On the State of the Art of Evaluation in Neural Language Models. <a href="index.html#fnref:34" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:35"><p>Rei, M. (2017). Semi-supervised Multitask Learning for Sequence Labeling. In Proceedings of ACL 2017. <a href="index.html#fnref:35" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:36"><p>Ramachandran, P., Liu, P. J., &amp; Le, Q. V. (2016). Unsupervised Pretrainig for Sequence to Sequence Learning. arXiv Preprint arXiv:1611.02683. <a href="index.html#fnref:36" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:37"><p>Kadlec, R., Schmid, M., Bajgar, O., &amp; Kleindienst, J. (2016). Text Understanding with the Attention Sum Reader Network. In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics. <a href="index.html#fnref:37" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:38"><p>Cheng, J., Dong, L., &amp; Lapata, M. (2016). Long Short-Term Memory-Networks for Machine Reading. arXiv Preprint arXiv:1601.06733. Retrieved from <a href="http://arxiv.org/abs/1601.06733">http://arxiv.org/abs/1601.06733</a> <a href="index.html#fnref:38" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:39"><p>Parikh, A. P., Täckström, O., Das, D., &amp; Uszkoreit, J. (2016). A Decomposable Attention Model for Natural Language Inference. In Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing. Retrieved from <a href="http://arxiv.org/abs/1606.01933">http://arxiv.org/abs/1606.01933</a> <a href="index.html#fnref:39" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:40"><p>Paulus, R., Xiong, C., &amp; Socher, R. (2017). A Deep Reinforced Model for Abstractive Summarization. In arXiv preprint arXiv:1705.04304,. Retrieved from <a href="http://arxiv.org/abs/1705.04304">http://arxiv.org/abs/1705.04304</a> <a href="index.html#fnref:40" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:41"><p>Liu, Y., &amp; Lapata, M. (2017). Learning Structured Text Representations. In arXiv preprint arXiv:1705.09207. Retrieved from <a href="http://arxiv.org/abs/1705.09207">http://arxiv.org/abs/1705.09207</a> <a href="index.html#fnref:41" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:42"><p>Zhang, J., Mitliagkas, I., &amp; Ré, C. (2017). YellowFin and the Art of Momentum Tuning. arXiv preprint arXiv:1706.03471. <a href="index.html#fnref:42" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:43"><p>Goldberg, Y. (2016). A Primer on Neural Network Models for Natural Language Processing. Journal of Artificial Intelligence Research, 57, 345–420. <a href="https://doi.org/10.1613/jair.4992">https://doi.org/10.1613/jair.4992</a> <a href="index.html#fnref:43" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:44"><p>Melamud, O., McClosky, D., Patwardhan, S., &amp; Bansal, M. (2016). The Role of Context Types and Dimensionality in Learning Word Embeddings. In Proceedings of NAACL-HLT 2016 (pp. 1030–1040). Retrieved from <a href="http://arxiv.org/abs/1601.00893">http://arxiv.org/abs/1601.00893</a> <a href="index.html#fnref:44" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:45"><p>Ruder, S., Ghaffari, P., &amp; Breslin, J. G. (2016). A Hierarchical Model of Reviews for Aspect-based Sentiment Analysis. Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing (EMNLP-16), 999–1005. Retrieved from <a href="http://arxiv.org/abs/1609.02745">http://arxiv.org/abs/1609.02745</a> <a href="index.html#fnref:45" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:46"><p>Reimers, N., &amp; Gurevych, I. (2017). Optimal Hyperparameters for Deep LSTM-Networks for Sequence Labeling Tasks. In arXiv preprint arXiv:1707.06799: Retrieved from <a href="https://arxiv.org/pdf/1707.06799.pdf">https://arxiv.org/pdf/1707.06799.pdf</a> <a href="index.html#fnref:46" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:47"><p>Søgaard, A., &amp; Goldberg, Y. (2016). Deep multi-task learning with low level tasks supervised at lower layers. Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics, 231–235. <a href="index.html#fnref:47" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:48"><p>Liu, P., Qiu, X., &amp; Huang, X. (2017). Adversarial Multi-task Learning for Text Classification. In ACL 2017. Retrieved from <a href="http://arxiv.org/abs/1704.05742">http://arxiv.org/abs/1704.05742</a> <a href="index.html#fnref:48" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:49"><p>Ruder, S., Bingel, J., Augenstein, I., &amp; Søgaard, A. (2017). Sluice networks: Learning what to share between loosely related tasks. arXiv Preprint arXiv:1705.08142. Retrieved from <a href="http://arxiv.org/abs/1705.08142">http://arxiv.org/abs/1705.08142</a> <a href="index.html#fnref:49" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:50"><p>Dozat, T., &amp; Manning, C. D. (2017). Deep Biaffine Attention for Neural Dependency Parsing. In ICLR 2017. Retrieved from <a href="http://arxiv.org/abs/1611.01734">http://arxiv.org/abs/1611.01734</a> <a href="index.html#fnref:50" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:51"><p>Jean, S., Cho, K., Memisevic, R., &amp; Bengio, Y. (2015). On Using Very Large Target Vocabulary for Neural Machine Translation. Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers), 1–10. Retrieved from <a href="http://www.aclweb.org/anthology/P15-1001">http://www.aclweb.org/anthology/P15-1001</a> <a href="index.html#fnref:51" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:52"><p>Sennrich, R., Haddow, B., &amp; Birch, A. (2016). Edinburgh Neural Machine Translation Systems for WMT 16. In Proceedings of the First Conference on Machine Translation (WMT 2016). Retrieved from <a href="http://arxiv.org/abs/1606.02891">http://arxiv.org/abs/1606.02891</a> <a href="index.html#fnref:52" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:53"><p>Huang, G., Li, Y., Pleiss, G., Liu, Z., Hopcroft, J. E., &amp; Weinberger, K. Q. (2017). Snapshot Ensembles: Train 1, get M for free. In ICLR 2017. <a href="index.html#fnref:53" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:54"><p>Inan, H., Khosravi, K., &amp; Socher, R. (2016). Tying Word Vectors and Word Classifiers: A Loss Framework for Language Modeling. arXiv Preprint arXiv:1611.01462. <a href="index.html#fnref:54" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:55"><p>Press, O., &amp; Wolf, L. (2017). Using the Output Embedding to Improve Language Models. Proceedings of the 15th Conference of the European Chapter of the Association for Computational Linguistics: Volume 2, Short Papers, 2, 157--163. <a href="index.html#fnref:55" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:56"><p>Snoek, J., Larochelle, H., &amp; Adams, R. P. (2012). Practical Bayesian Optimization of Machine Learning Algorithms. Neural Information Processing Systems Conference (NIPS 2012). <a href="https://doi.org/2012arXiv1206.2944S">https://doi.org/2012arXiv1206.2944S</a> <a href="index.html#fnref:56" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:57"><p>Mikolov, T. (2012). Statistical language models based on neural networks (Doctoral dissertation, PhD thesis, Brno University of Technology). <a href="index.html#fnref:57" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:58"><p>Pascanu, R., Mikolov, T., &amp; Bengio, Y. (2013). On the difficulty of training recurrent neural networks. International Conference on Machine Learning, (2), 1310–1318. <a href="https://doi.org/10.1109/72.279181">https://doi.org/10.1109/72.279181</a> <a href="index.html#fnref:58" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:59"><p>Zhang, Y., &amp; Wallace, B. (2015). A Sensitivity Analysis of (and Practitioners’ Guide to) Convolutional Neural Networks for Sentence Classification. arXiv Preprint arXiv:1510.03820, (1). Retrieved from <a href="http://arxiv.org/abs/1510.03820">http://arxiv.org/abs/1510.03820</a> <a href="index.html#fnref:59" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:60"><p>Huang, Z., Xu, W., &amp; Yu, K. (2015). Bidirectional LSTM-CRF Models for Sequence Tagging. arXiv preprint arXiv:1508.01991. <a href="index.html#fnref:60" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:61"><p>Ma, X., &amp; Hovy, E. (2016). End-to-end Sequence Labeling via Bi-directional LSTM-CNNs-CRF. arXiv Preprint arXiv:1603.01354. <a href="index.html#fnref:61" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:62"><p>Lample, G., Ballesteros, M., Subramanian, S., Kawakami, K., &amp; Dyer, C. (2016). Neural Architectures for Named Entity Recognition. NAACL-HLT 2016. <a href="index.html#fnref:62" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:63"><p>Kiddon, C., Zettlemoyer, L., &amp; Choi, Y. (2016). Globally Coherent Text Generation with Neural Checklist Models. Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing (EMNLP2016), 329–339. <a href="index.html#fnref:63" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:64"><p>Tu, Z., Lu, Z., Liu, Y., Liu, X., &amp; Li, H. (2016). Modeling Coverage for Neural Machine Translation. Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics. <a href="https://doi.org/10.1145/2856767.2856776">https://doi.org/10.1145/2856767.2856776</a> <a href="index.html#fnref:64" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:65"><p>See, A., Liu, P. J., &amp; Manning, C. D. (2017). Get To The Point: Summarization with Pointer-Generator Networks. In ACL 2017. <a href="index.html#fnref:65" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:66"><p>Sennrich, R., Haddow, B., &amp; Birch, A. (2016). Neural Machine Translation of Rare Words with Subword Units. In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics (ACL 2016). Retrieved from <a href="http://arxiv.org/abs/1508.07909">http://arxiv.org/abs/1508.07909</a> <a href="index.html#fnref:66" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:67"><p>Sutskever, I., Vinyals, O., &amp; Le, Q. V. (2014). Sequence to sequence learning with neural networks. Advances in Neural Information Processing Systems, 9. Retrieved from <a href="http://arxiv.org/abs/1409.3215%5Cnhttp://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks">http://arxiv.org/abs/1409.3215%5Cnhttp://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks</a> <a href="index.html#fnref:67" title="return to article">↩</a></p></li></ol></div>

<p>Credit for the cover image goes to Bahdanau et al. (2015).</p>
    </div>

    <div class="post related">
        <a rel="prev" id="prev-btn" class="btn small square" href="../multi-task/index.html">← An Overview of Multi-Task Learning in Deep Neural Networks</a>

    </div>

    <footer class="post comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + window.disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</footer>

  </article>


<script type="text/javascript"  
src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>  

        <footer>
  <span class="copyright">
    &copy; 2017. All rights reserved. Built with <a href="https://ghost.org/" target="_blank">Ghost</a> and <a href="https://github.com/Kikobeats/uno-zen" target="_blank">Uno Zen</a> theme.
  </span>
</footer>
      </section>
    </main>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.1.6/zepto.min.js"></script>
<script>jQuery = Zepto</script>
    <script src="../assets/js/uno-zen.js?v=874cc6af7f" type="text/javascript" charset="utf-8"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script>
  if (window.ga_id) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', window.ga_id, 'auto');
    ga('require', 'linkid', 'linkid.js');
    ga('send', 'pageview');
  }
</script>
  </body>
</html>

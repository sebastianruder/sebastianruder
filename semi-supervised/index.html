<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <title>An overview of proxy-label approaches for semi-supervised learning</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" type="text/css" href="../assets/built/screen.css?v=fbdba21d16" />

    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" />
    <link rel="canonical" href="https://ruder.io/semi-supervised/" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    <link rel="amphtml" href="https://ruder.io/semi-supervised/amp/" />
    
    <meta property="og:site_name" content="Sebastian Ruder" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="An overview of proxy-label approaches for semi-supervised learning" />
    <meta property="og:description" content="While unsupervised learning is still elusive, researchers have made a lot of progress in semi-supervised learning. This post focuses on a particular promising category of semi-supervised learning methods that assign proxy labels to unlabelled data, which are used as targets for learning." />
    <meta property="og:url" content="https://ruder.io/semi-supervised/" />
    <meta property="og:image" content="https://ruder.io/content/images/2018/10/mttri.png" />
    <meta property="article:published_time" content="2018-04-26T07:00:00.000Z" />
    <meta property="article:modified_time" content="2019-04-22T10:26:50.000Z" />
    <meta property="article:tag" content="semi-supervised learning" />
    <meta property="article:tag" content="transfer learning" />
    <meta property="article:tag" content="domain adaptation" />
    
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="An overview of proxy-label approaches for semi-supervised learning" />
    <meta name="twitter:description" content="While unsupervised learning is still elusive, researchers have made a lot of progress in semi-supervised learning. This post focuses on a particular promising category of semi-supervised learning methods that assign proxy labels to unlabelled data, which are used as targets for learning." />
    <meta name="twitter:url" content="https://ruder.io/semi-supervised/" />
    <meta name="twitter:image" content="https://ruder.io/content/images/2018/10/mttri.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Sebastian Ruder" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="semi-supervised learning, transfer learning, domain adaptation" />
    <meta name="twitter:site" content="@seb_ruder" />
    <meta property="og:image:width" content="1004" />
    <meta property="og:image:height" content="585" />
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Sebastian Ruder",
        "url": "https://ruder.io/",
        "logo": {
            "@type": "ImageObject",
            "url": {
                "@type": "ImageObject",
                "url": "https://ruder.io/favicon.ico",
                "width": 48,
                "height": 48
            }
        }
    },
    "author": {
        "@type": "Person",
        "name": "Sebastian Ruder",
        "image": {
            "@type": "ImageObject",
            "url": "https://ruder.io/content/images/2019/02/new_profile_photo_square-1.jpg",
            "width": 2000,
            "height": 2000
        },
        "url": "https://ruder.io/author/sebastian/",
        "sameAs": []
    },
    "headline": "An overview of proxy-label approaches for semi-supervised learning",
    "url": "https://ruder.io/semi-supervised/",
    "datePublished": "2018-04-26T07:00:00.000Z",
    "dateModified": "2019-04-22T10:26:50.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "https://ruder.io/content/images/2018/10/mttri.png",
        "width": 1004,
        "height": 585
    },
    "keywords": "semi-supervised learning, transfer learning, domain adaptation",
    "description": "While unsupervised learning is still elusive, researchers have made a lot of progress in semi-supervised learning. This post focuses on a particular promising category of semi-supervised learning methods that assign proxy labels to unlabelled data, which are used as targets for learning.",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://ruder.io/"
    }
}
    </script>

    <meta name="generator" content="Ghost 3.11" />
    <link rel="alternate" type="application/rss+xml" title="Sebastian Ruder" href="https://ruder.io/rss/" />
    <script>
var profile_title = 'Sebastian Ruder';
</script>
<script>
var disqus_shortname = 'sebastianruder';
</script>
<script>
var profile_resume ='NLP PhD student';
</script>
<script>
var ga_id = 'UA-60512592-1';
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [["$", "$"], ["\\(", "\\)"]],
        processEscapes: true
    }
});
</script>

</head>
<body class="post-template tag-semi-supervised-learning tag-transfer-learning tag-domain-adaptation">

    <div class="site-wrapper">

        

<header class="site-header">
    <div class="outer site-nav-main">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left-wrapper">
        <div class="site-nav-left">
                <a class="site-nav-logo" href="https://ruder.io">Sebastian Ruder</a>
            <div class="site-nav-content">
                    <ul class="nav" role="menu">
    <li class="nav-about" role="menuitem"><a href="https://ruder.io/about/">About</a></li>
    <li class="nav-tags" role="menuitem"><a href="https://ruder.io/tags/">Tags</a></li>
    <li class="nav-papers" role="menuitem"><a href="https://ruder.io/publications/">Papers</a></li>
    <li class="nav-talks" role="menuitem"><a href="https://ruder.io/talks/">Talks</a></li>
    <li class="nav-news" role="menuitem"><a href="https://ruder.io/news/">News</a></li>
    <li class="nav-faq" role="menuitem"><a href="https://ruder.io/faq/">FAQ</a></li>
    <li class="nav-sign-up-for-nlp-news" role="menuitem"><a href="https://ruder.io/nlp-news/">Sign up for NLP News</a></li>
    <li class="nav-nlp-progress" role="menuitem"><a href="https://nlpprogress.com/">NLP Progress</a></li>
    <li class="nav-media" role="menuitem"><a href="https://ruder.io/media/">Media</a></li>
    <li class="nav-contact" role="menuitem"><a href="https://ruder.io/contact/">Contact</a></li>
</ul>

                    <span class="nav-post-title dash">An overview of proxy-label approaches for semi-supervised learning</span>
            </div>
        </div>
    </div>
    <div class="site-nav-right">
            <div class="social-links">
                    <a class="social-link social-link-tw" href="https://twitter.com/seb_ruder" title="Twitter" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>
</a>
            </div>
                <a class="rss-button" href="https://ruder.io/rss/index.rss" title="RSS" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="6.18" cy="17.82" r="2.18"/><path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/></svg>
</a>

    </div>
</nav>
    </div>
</div></header>


<main id="site-main" class="site-main outer">
    <div class="inner">

        <article class="post-full post tag-semi-supervised-learning tag-transfer-learning tag-domain-adaptation ">

            <header class="post-full-header">

                <section class="post-full-tags">
                    <a href="../tag/semi-supervised-learning/index.html">semi-supervised learning</a>
                </section>

                <h1 class="post-full-title">An overview of proxy-label approaches for semi-supervised learning</h1>

                <p class="post-full-custom-excerpt">While unsupervised learning is still elusive, researchers have made a lot of progress in semi-supervised learning. This post focuses on a particular promising category of semi-supervised learning methods that assign proxy labels to unlabelled data, which are used as targets for learning.</p>

                <div class="post-full-byline">

                    <section class="post-full-byline-content">

                        <ul class="author-list">
                            <li class="author-list-item">

                                <div class="author-card">
                                    <img class="author-profile-image" src="../content/images/size/w100/2019/02/new_profile_photo_square-1.jpg" alt="Sebastian Ruder" />
                                    <div class="author-info">
                                        <h2>Sebastian Ruder</h2>
                                        <p>Read <a href="../author/sebastian/index.html">more posts</a> by this author.</p>
                                    </div>
                                </div>

                                <a href="../author/sebastian/index.html" class="author-avatar">
                                    <img class="author-profile-image" src="../content/images/size/w100/2019/02/new_profile_photo_square-1.jpg" alt="Sebastian Ruder" />
                                </a>

                            </li>
                        </ul>

                        <section class="post-full-byline-meta">
                            <h4 class="author-name"><a href="../author/sebastian/index.html">Sebastian Ruder</a></h4>
                            <div class="byline-meta-content">
                                <time class="byline-meta-date" datetime="2018-04-26">26 Apr 2018</time>
                                <span class="byline-reading-time"><span class="bull">&bull;</span> 19 min read</span>
                            </div>
                        </section>

                    </section>


                </div>
            </header>

            <figure class="post-full-image">
                <img
                    srcset="../content/images/size/w300/2018/10/mttri.png 300w,
                           ../content/images/size/w600/2018/10/mttri.png 600w,
                          ../content/images/size/w1000/2018/10/mttri.png 1000w,
                         ../content/images/size/w2000/2018/10/mttri.png 2000w"
                    sizes="(max-width: 800px) 400px,
                        (max-width: 1170px) 1170px,
                            2000px"
                    src="../content/images/size/w2000/2018/10/mttri.png"
                    alt="An overview of proxy-label approaches for semi-supervised learning"
                />
            </figure>

            <section class="post-full-content">
                <div class="post-content">
                    <!--kg-card-begin: markdown--><p>This post discusses semi-supervised learning algorithms that learn from <em>proxy labels</em> assigned to unlabelled data.</p>
<p>Note: Parts of this post are based on my ACL 2018 paper <a href="https://arxiv.org/abs/1804.09530">Strong Baselines for Neural Semi-supervised Learning under Domain Shift</a> with <a href="http://www.let.rug.nl/bplank/">Barbara Plank</a>.</p>
<p>Table of contents:</p>
<ul>
<li><a href="index.html#selftraining">Self-training</a></li>
<li><a href="index.html#multiviewtraining">Multi-view training</a>
<ul>
<li>Co-training</li>
<li>Democratic Co-learning</li>
<li>Tri-training</li>
<li>Tri-training with disagreement</li>
<li>Asymmetric tri-training</li>
<li>Multi-task tri-training</li>
</ul>
</li>
<li><a href="index.html#selfensembling">Self-ensembling</a>
<ul>
<li>Ladder networks</li>
<li>Virtual Adversarial Training</li>
<li>\(\Pi\) model</li>
<li>Temporal Ensembling</li>
<li>Mean Teacher</li>
</ul>
</li>
<li><a href="index.html#relatedmethodsandareas">Related methods and areas</a>
<ul>
<li>Distillation</li>
<li>Learning from weak supervision</li>
<li>Learning with noisy labels</li>
<li>Data augmentation</li>
<li>Ensembling a single model</li>
</ul>
</li>
</ul>
<p>Unsupervised learning constitutes one of the main challenges for current machine learning models and one of the key elements that is missing for <a href="http://ruder.io/highlights-nips-2016/#generalartificialintelligence">general artificial intelligence</a>. While unsupervised learning on its own is still elusive, researchers have a made a lot of progress in <em>combining</em> unsupervised learning with supervised learning. This branch of machine learning research is called semi-supervised learning.</p>
<p>Semi-supervised learning has a long history. For a (slightly outdated) overview, refer to Zhu (2005) <sup class="footnote-ref"><a href="index.html#fn1" id="fnref1">[1]</a></sup> and Chapelle et al. (2006) <sup class="footnote-ref"><a href="index.html#fn2" id="fnref2">[2]</a></sup>. Particularly recently, semi-supervised learning has seen some success, considerably reducing the error rate on important benchmarks. Semi-supervised learning also makes an appearance in <a href="https://www.sec.gov/Archives/edgar/data/1018724/000119312518121161/d456916dex991.htm">Amazon's annual letter to shareholders</a> where it is credited with reducing the amount of labelled data needed to achieve the same accuracy improvement by \(40\times\).</p>
<p>In this blog post, I will focus on a particular class of semi-supervised learning algorithms that produce <em>proxy labels</em> on unlabelled data, which are used as targets together with the labelled data. These proxy labels are produced by the model itself or variants of it without any additional supervision; they thus do not reflect the ground truth but might still provide some signal for learning. In a sense, these labels can be considered <em>noisy</em> or <em>weak</em>. I will highlight the connection to learning from noisy labels, weak supervision as well as other related topics in the end of this post.</p>
<p>This class of models is of particular interest in my opinion, as a) deep neural networks have been shown to be good at dealing with noisy labels and b) these models have achieved state-of-the-art in semi-supervised learning for computer vision. Note that many of these ideas are not new and many related methods have been developed in the past. In one half of this post, I will thus cover classic methods and discuss their relevance for current approaches; in the other half, I will discuss techniques that have recently achieved state-of-the-art performance. Some of the following approaches have been referred to as <em>self-teaching</em> or <em>bootstrapping</em> algorithms; I am not aware of a term that captures all of them, so I will simply refer to them as <em>proxy-label</em> methods.</p>
<p>I will divide these methods in three groups, which I will discuss in the following: 1) self-training, which uses a model's own predictions as proxy labels; 2) multi-view learning, which uses the predictions of models trained with different <em>views</em> of the data; and 3) self-ensembling, which ensembles variations of a model's own predictions and uses these as feedback for learning. I will show pseudo-code for the most important algorithms. You can find the LaTeX source <a href="https://github.com/sebastianruder/semi-supervised">here</a>.</p>
<p>There are many interesting and equally important directions for semi-supervised learning that I will not cover in this post, e.g. graph-convolutional neural networks <sup class="footnote-ref"><a href="index.html#fn3" id="fnref3">[3]</a></sup>.</p>
<h2 id="selftraining">Self-training</h2>
<p>Self-training (Yarowsky, 1995; McClosky et al., 2006) <sup class="footnote-ref"><a href="index.html#fn4" id="fnref4">[4]</a></sup> <sup class="footnote-ref"><a href="index.html#fn5" id="fnref5">[5]</a></sup> is one of the earliest and simplest approaches to semi-supervised learning and the most straightforward example of how a model's own predictions can be incorporated into training. As the name implies, self-training leverages a model's own predictions on unlabelled data in order to obtain additional information that can be used during training. Typically the most confident predictions are taken at face value, as detailed next.</p>
<p>Formally, self-training trains a model \(m\) on a labeled training set \(L\) and an unlabeled data set \(U\). At each iteration, the model provides predictions \(m(x)\) in the form of a probability distribution over the \(C\) classes for all unlabeled examples \(x\) in \(U\). If the probability assigned to the most likely class is higher than a predetermined threshold \(\tau\), \(x\) is added to the labeled examples with \(\DeclareMathOperator*{\argmax}{argmax} p(x) = \argmax m(x)\) as pseudo-label. This process is generally repeated for a fixed number of iterations or until no more predictions on unlabelled examples are confident. This instantiation is the most widely used and shown in Algorithm 1.<br>
<img src="https://ruder.io/content/images/2018/03/self-training.png" alt=""><br>
Classic self-training has shown mixed success. In parsing it proved successful with small datasets (Reichart, and Rappoport, 2007; Huang and Harper, 2009) <sup class="footnote-ref"><a href="index.html#fn6" id="fnref6">[6]</a></sup> <sup class="footnote-ref"><a href="index.html#fn7" id="fnref7">[7]</a></sup> or when a generative component is used together with a reranker when more data is available (McClosky et al., 2006; Suzuki and Isozaki , 2008) <sup class="footnote-ref"><a href="index.html#fn8" id="fnref8">[8]</a></sup>. Some success was achieved with careful task-specific data selection (Petrov and McDonald, 2012) <sup class="footnote-ref"><a href="index.html#fn9" id="fnref9">[9]</a></sup>, while others report limited success on a variety of NLP tasks (He and Zhou, 2011; Plank, 2011; Van Asch and Daelemans, 2016; van der Goot et al., 2017) <sup class="footnote-ref"><a href="index.html#fn10" id="fnref10">[10]</a></sup> <sup class="footnote-ref"><a href="index.html#fn11" id="fnref11">[11]</a></sup> <sup class="footnote-ref"><a href="index.html#fn12" id="fnref12">[12]</a></sup> <sup class="footnote-ref"><a href="index.html#fn13" id="fnref13">[13]</a></sup>.</p>
<p>The main downside of self-training is that the model is unable to correct its own mistakes. If the model's predictions on unlabelled data are confident but wrong, the erroneous data is nevertheless incorporated into training and the model's errors are amplified. This effect is exacerbated if the domain of the unlabelled data is different from that of the labelled data; in this case, the model's confidence will be a poor predictor of its performance.</p>
<h2 id="multiviewtraining">Multi-view training</h2>
<p>Multi-view training aims to train different models with different <em>views</em> of the data. Ideally, these views complement each other and the models can collaborate in improving each other's performance. These views can differ in different ways such as in the features they use, in the architectures of the models, or in the data on which the models are trained.</p>
<p><strong>Co-training</strong>   Co-training (Blum and Mitchell, 1998) <sup class="footnote-ref"><a href="index.html#fn14" id="fnref14">[14]</a></sup> is a classic multi-view training method, which makes comparatively strong assumptions. It requires that the data \(L\) can be represented using two conditionally independent feature sets \(L^1\) and \(L^2\) and that each feature set is sufficient to train a good model. After the initial models \(m_1\) and \(m_2\) are trained on their respective feature sets, at each iteration, only inputs that are confident (i.e. have a probability higher than a threshold \(\tau\)) according to <em>exactly one</em> of the two models are moved to the training set of <em>the other</em> model. One model thus provides the labels to the inputs on which the <em>other</em> model is uncertain. Co-training can be seen in Algorithm 2.<br>
<img src="https://ruder.io/content/images/2018/04/co-training.png" alt=""><br>
In the original co-training paper (Blum and Mitchell, 1998), co-training is used to classify web pages using the text on the page as one view and the anchor text of hyperlinks on other pages pointing to the page as the other view. As two conditionally independent views are not always available, Chen et al. (2011) <sup class="footnote-ref"><a href="index.html#fn15" id="fnref15">[15]</a></sup> propose pseudo-multiview regularization (Chen et al., 2011) in order to split the features into two mutually exclusive views so that co-training is effective. To this end, pseudo-multiview regularization constrains the models so that at least one of them has a zero weight for each feature. This is similar to the orthogonality constraint recently used in domain adaptation to encourage shared and private spaces (Bousmalis et al., 2016) <sup class="footnote-ref"><a href="index.html#fn16" id="fnref16">[16]</a></sup>. A second constraint requires the models to be confident on different subsets of \(U\). Chen et al. (2011) <sup class="footnote-ref"><a href="index.html#fn17" id="fnref17">[17]</a></sup> use pseudo-multiview regularization to adapt co-training to domain adaptation.</p>
<p><strong>Democratic Co-learning</strong> Rather than treating different feature sets as views, democratic co-learning (Zhou and Goldman, 2004) <sup class="footnote-ref"><a href="index.html#fn18" id="fnref18">[18]</a></sup> employs models with <em>different inductive biases</em>. These can be different network architectures in the case of neural networks or completely different learning algorithms. Democratic co-learning first trains each model separately on the complete labelled data \(L\). The models then make predictions on the unlabelled data \(U\). If a majority of models confidently agree on the label of an example, the example is added to the labelled dataset. Confidence is measured in the original formulation by measuring if the sum of the mean confidence intervals \(w\) of the models, which agreed on the label is larger than the sum of the models that disagreed. This process is repeated until no more examples are added. The final prediction is made with a majority vote weighted with the confidence intervals of the models. The full algorithm can be seen below. \(M\) is the set of all models that predict the same label \(j\) for an example \(x\).<br>
<img src="https://ruder.io/content/images/2018/04/democratic_co-learning-2.png" alt=""><br>
<strong>Tri-training</strong>   Tri-training (Zhou and Li, 2005) <sup class="footnote-ref"><a href="index.html#fn19" id="fnref19">[19]</a></sup> is one of the best known multi-view training   methods. It can be seen as an instantiation of democratic co-learning, which leverages the agreement of three independently trained models to reduce the bias of predictions on unlabeled data. The main requirement for tri-training is that the initial models are diverse. This can be achieved using different model architectures as in democratic co-learning. The most common way to obtain diversity for tri-training, however, is to obtain different variations \(S_i\) of the original training data \(L\) using bootstrap sampling. The three models \(m_1\), \(m_2\), and \(m_3\) are then trained on these bootstrap samples, as depicted in Algorithm 4. An unlabeled data point is added to the training set of a model \(m_i\) if the other two models \(m_j\) and \(m_k\) agree on its label. Training stops when the classifiers do not change anymore.<br>
<img src="https://ruder.io/content/images/2018/04/tri-training.png" alt=""><br>
Despite having been proposed more than 10 years ago, before the advent of Deep Learning, we found in a <a href="https://arxiv.org/abs/1804.09530">recent paper</a> (Ruder and Plank, 2018) <sup class="footnote-ref"><a href="index.html#fn20" id="fnref20">[20]</a></sup> that classic tri-training is a strong baseline for neural semi-supervised with and without domain shift for NLP and that it outperforms even recent state-of-the-art methods.</p>
<p><strong>Tri-training with disagreement</strong>   Tri-training <em>with disagreement</em> (Søgaard, 2010) <sup class="footnote-ref"><a href="index.html#fn21" id="fnref21">[21]</a></sup> is based on the intuition that a model should only be strengthened in its weak points and that the labeled data should not be skewed by easy data points. In order to achieve this, it adds a simple modification to the original algorithm (altering line 8 in Algorithm 4), requiring that for an unlabeled data point on which \(m_j\) and \(m_k\) <em>agree</em>, the other model \(m_i\) <em>disagrees</em> on the prediction. Tri-training with disagreement is more data-efficient than tri-training and has achieved competitive results on part-of-speech tagging (Søgaard, 2010).</p>
<p><strong>Asymmetric tri-training</strong>   Asymmetic tri-training (Saito et al., 2017) <sup class="footnote-ref"><a href="index.html#fn22" id="fnref22">[22]</a></sup> is a recently proposed extension of tri-training that achieved state-of-the-art results for unsupervised domain adaptation in computer vision. For unsupervised domain adaptation, the test data and unlabeled data are from a different domain than the labelled examples. To adapt tri-training to this shift, asymmetric tri-training learns one of the models <em>only</em> on proxy labels and not on labelled examples (a change to line 10 in Algorithm 4) and uses only this model to classify target domain examples at test time. In addition, all three models share the same feature extractor.</p>
<p><strong>Multi-task tri-training</strong>   Tri-training typically relies on training separate models on bootstrap samples of a potentially large amount of training data, which is expensive. Multi-task tri-training (MT-Tri) (Ruder and Plank, 2018) aims to reduce both the time and space complexity of tri-training by leveraging insights from multi-task learning (MTL) (Caruana, 1993) <sup class="footnote-ref"><a href="index.html#fn23" id="fnref23">[23]</a></sup> to share knowledge across models and accelerate training. Rather than storing and training each model separately, MT-Tri shares the parameters of the models and trains them jointly using MTL. Note that the model does only <em>pseudo</em> MTL as all three models effectively perform the same task.</p>
<p>The output softmax layers are model-specific and are only updated for the input of the respective model. As the models leverage a joint representation, diversity is even more crucial. We need to ensure that the features used for prediction in the softmax layers of the different models are as diverse as possible, so that the models can still learn from each other's predictions. In contrast, if the parameters in all output softmax layers were the same, the method would degenerate to self-training. Similar to pseudo-view regularization, we thus use an orthogonality constraint (Bousmalis et al., 2016) on two of the three softmax output layers as an additional loss term.</p>
<p>The pseudo-code can be seen below. In contrast to classic tri-training, we can train the multi-task model with its three model-specific outputs jointly and <em>without</em> bootstrap sampling on the labeled source domain data until convergence, as the orthogonality constraint enforces different representations between models \(m_1\) and \(m_2\). From this point, we can leverage the pair-wise agreement of two output layers to add pseudo-labeled examples as training data to the third model. We train the third output layer \(m_3\) only on pseudo-labeled target instances in order to make tri-training more robust to a domain shift. For the final prediction, we use majority voting of all three output layers. For more information about multi-task tri-training, self-training, other tri-training variants, you can refer to our recent <a href="https://arxiv.org/abs/1804.09530">ACL 2018 paper</a>.<br>
<img src="https://ruder.io/content/images/2018/04/multi-task_tri-training-1.png" alt=""></p>
<h2 id="selfensembling">Self-ensembling</h2>
<p>Self-ensembling methods are very similar to multi-view learning approaches in that they combine different variants of a model. Multi-task tri-training, for instance, can also be seen as a self-ensembling method where different variations of a model are used to create a stronger ensemble prediction. In contrast to multi-view learning, diversity is not a key concern. Self-ensembling approaches mostly use a single model under different configurations in order to make the model's predictions more robust. Most of the following methods are very recent and several have achieved state-of-the-art results in computer vision.</p>
<p><strong>Ladder networks</strong>   The \(\Gamma\) (gamma) version of Ladder Networks (Rasmus et al., 2015) <sup class="footnote-ref"><a href="index.html#fn24" id="fnref24">[24]</a></sup> aims to make a model more robust to noise. For each unlabelled example, it uses the model's prediction on the clean example as a proxy label for prediction on a perturbed version of the example. This way, the model learns to develop features that are invariant to noise and predictive of the labels on the labelled training data. Ladder networks have been mostly used in computer vision where many forms of perturbation and data augmentation are available.</p>
<p><strong>Virtual Adversarial Training</strong>   If perturbing the original sample is not possible or desired, we can instead perturb the example in feature space. Rather than randomly perturbing it by e.g. adding dropout, we can apply the <em>worst possible</em> perturbation for the model, which transforms the input into an adversarial sample. While adversarial training requires access to the labels to perform these perturbations, <em>virtual</em> adversarial training (Miyato et al., 2017) <sup class="footnote-ref"><a href="index.html#fn25" id="fnref25">[25]</a></sup> requires no labels and is thus suitable for semi-supervised learning. Virtual adversarial training effectively seeks to make the model robust to perturbations in directions to which it is most sensitive and has achieved good results on text classification datasets.</p>
<p><strong>\(\Pi\) model</strong>   Rather than treating clean predictions as proxy labels, the \(\Pi\) (pi) model (Laine and Aila, 2017) <sup class="footnote-ref"><a href="index.html#fn26" id="fnref26">[26]</a></sup> ensembles the predictions of the model under two different perturbations of the input data and two different dropout conditions \(z\) and \(\tilde{z}\). The full pseudo-code can be seen in Algorithm 6 below. \(g(x)\) is the stochastic input augmentation function. The first loss term encourages the predictions under the two different noise settings to be consistent, with \(\lambda\) determining the contribution, while the second loss term is the standard cross-entropy loss \(H\) with respect to the label \(y\). In contrast to the models we encountered before, we apply the unsupervised loss component to both unlabelled and labelled examples.<br>
<img src="https://ruder.io/content/images/2018/04/pi-model-3.png" alt=""><br>
<strong>Temporal Ensembling</strong>   Instead of ensembling over the same model under different noise configurations, we can ensemble over different models. As training separate models is expensive, we can instead ensemble the predictions of a model <em>at different timesteps</em>. We can save the ensembled proxy labels \(Z\) as an exponential moving average of the model's past predictions on all examples as depicted below in order to save space. As we initialize the proxy labels as a zero vector, they are biased towards \(0\). We can correct this bias similar to Adam (Kingma and Ba, 2015) <sup class="footnote-ref"><a href="index.html#fn27" id="fnref27">[27]</a></sup> based on the current epoch \(t\) to obtain bias-corrected target vectors \(\tilde{z}\). We then update the model similar to the \(\Pi\) model.<br>
<img src="https://ruder.io/content/images/2018/04/temporal_ensembling-3.png" alt=""></p>
<p><strong>Mean Teacher</strong>   Finally, instead of averaging the <em>predictions</em> of our model over training time, we can average the model weights. Mean teacher (Tarvainen and Valpola, 2017) <sup class="footnote-ref"><a href="index.html#fn28" id="fnref28">[28]</a></sup> stores an exponential moving average of the model parameters. For every example, this mean teacher model is then used to obtain proxy labels \(\tilde{z}\). The consistency loss and supervised loss are computed as in temporal ensembling.</p>
<p>Mean teacher has achieved state-of-the-art results for semi-supervised learning for computer vision. For reference, on ImageNet with 10% of the labels, it achieves an error rate of \(9.11\), compared to an error rate of \(3.79\) using <em>all</em> labels with the state-of-the-art. For more information about self-ensembling methods, have a look at <a href="https://thecuriousaicompany.com/mean-teacher/">this intuitive blog post</a> by the Curious AI company. We have run experiments with temporal ensembling for NLP tasks, but did not manage to obtain consistent results. My assumption is that the unsupervised consistency loss is more suitable for continuous inputs. Mean teacher might work better, as averaging weights aka Polyak averaging (Polyak and Juditsky, 1992) <sup class="footnote-ref"><a href="index.html#fn29" id="fnref29">[29]</a></sup> is a tried method for accelerating optimization.</p>
<p>Very recently, Oliver et al. (2018) <sup class="footnote-ref"><a href="index.html#fn30" id="fnref30">[30]</a></sup> raise some questions regarding the true applicability of these methods: They find that the performance difference to a properly tuned supervised baseline is smaller than typically reported, that transfer learning from a labelled dataset (e.g. ImageNet) outperforms the presented methods, and that performance degrades severely under a domain shift. In order to deal with the latter, algorithms such as asymmetric or multi-task tri-training learn different representations for the target distribution. It remains to be seen if these insights translate to other domains; a combination of transfer learning and semi-supervised adaptation to the target domain seems particularly promising.</p>
<h2 id="relatedmethodsandareas">Related methods and areas</h2>
<p><strong>Distillation</strong>   Proxy-label approaches can be seen as different forms of distillation (Hinton et al., 2015) <sup class="footnote-ref"><a href="index.html#fn31" id="fnref31">[31]</a></sup>. Distillation was originally conceived as a method to compress the information of a large model or an ensemble in a smaller model. In the standard setup, a typically large and fully trained <em>teacher</em> model provides proxy targets for a <em>student</em> model, which is generally smaller and faster. Self-learning is akin to distillation without a teacher, where the student is left to learn by themselves and with no-one to correct its mistakes. For multi-view learning, different models work together to teach each other, alternately acting as both teachers and students. Self-ensembling, finally, has one model assuming the dual role of teacher and student: As a teacher, it generates new targets, which are then incorporated by itself as a student for learning.</p>
<p><strong>Learning from weak supervision</strong>   Learning from weak supervision, as the name implies, can be seen as a weaker form of supervised learning or alternatively as a stronger form of semi-supervised learning: While supervised learning provides us with labels that we know to be correct and semi-supervised learning only provides us with a small set of labelled examples, weak supervision allows us to obtain labels that we know to be noisy for the unlabelled data as a further signal for learning. Typically, the weak annotator is an unsupervised method that is very different from the model we use for learning the task. For sentiment analysis, this could be a simple lexicon-based method <sup class="footnote-ref"><a href="index.html#fn32" id="fnref32">[32]</a></sup>. Many of the presented methods could be extended to the weak supervision setting by incorporating the weak labels as feedback. Self-ensembling methods, for instance, might employ another teacher model that gauges the quality of weakly annotated examples similar to Deghani et al. (2018) <sup class="footnote-ref"><a href="index.html#fn33" id="fnref33">[33]</a></sup>. For an overview of weak supervision, have a look at <a href="https://hazyresearch.github.io/snorkel/blog/ws_blog_post.html">this blog post</a> by Stanford's Hazy Research group.</p>
<p><strong>Learning with noisy labels</strong>   Learning with noisy labels is similar to learning from weak supervision. In both cases, labels are available that cannot be completely trusted. For learning with noisy labels, labels are typically assumed to be permuted with a fixed random permutation. While proxy-label approaches supply the noisy labels themselves, when learning with noisy labels, the labels are part of the data. Similar to learning from weak supervision, we can try to model the noise to assess the quality of the labels (Sukhbaatar et al., 2015) <sup class="footnote-ref"><a href="index.html#fn34" id="fnref34">[34]</a></sup>. Similar to self-ensembling methods, we can enforce consistency between the model's preditions and the proxy labels (Reed et al., 2015) <sup class="footnote-ref"><a href="index.html#fn35" id="fnref35">[35]</a></sup>.</p>
<p><strong>Data augmentation</strong>   Several self-ensembling methods employ data augmentation to enforce consistency between model predictions under different noise settings. Data augmentation is mostly used in computer vision, but  noise in the form of different dropout masks can also be applied to the model parameters as in the \(\Pi\) model and has also been used in LSTMs (Zolna et al., 2018) <sup class="footnote-ref"><a href="index.html#fn36" id="fnref36">[36]</a></sup>. While regularization in the form of dropout, batch normalization, etc. can be used when labels are available in order to make predictions more robust, a consistency loss is required in the case without labels. For supervised learning, adversarial training can be employed to obtain adversarial examples and has been used successfully e.g. for part-of-speech tagging (Yasunaga et al., 2018) <sup class="footnote-ref"><a href="index.html#fn37" id="fnref37">[37]</a></sup>.</p>
<p><strong>Ensembling a single model</strong>   The discussed self-ensembling methods all employ ensemble predictions not just to make predictions more robust, but as feedback to improve the model itself during training in a self-reinforcing loop. In the supervised setting, this feedback might not be necessary; ensembling a single model is still useful, however, to save time compared to training multiple models. Two methods that have been proposed to ensemble a model from a single training run are checkpoint ensembles and snapshot ensembles. Checkpoint ensembles (Sennrich et al., 2016) <sup class="footnote-ref"><a href="index.html#fn38" id="fnref38">[38]</a></sup> ensemble the last \(n\) checkpoints of a single training run and have been used to achieve state-of-the-art in machine translation. Snapshot ensembles (Huang et al., 2017) <sup class="footnote-ref"><a href="index.html#fn39" id="fnref39">[39]</a></sup> ensemble models converged to different minima during a training run and have been used to achieve state-of-the-art in object recognition.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I hope this post was able to give you an insight into a part of the semi-supervised learning landscape that seems to be particularly useful to improve the performance of current models. While learning completely without labelled data is unrealistic at this point, semi-supervised learning enables us to augment our small labelled datasets with large amounts of available unlabelled data. Most of the discussed methods are promising in that they treat the model as a black box and can thus be used with any existing supervised learning model. As always, if you have any questions or noticed any mistakes, feel free to write a comment in the comments section below.</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Zhu, X. (2005). Semi-Supervised Learning Literature Survey. <a href="index.html#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Chapelle, O., Schölkopf, B., &amp; Zien, A. (2006). Semi-Supervised Learning. Interdisciplinary sciences computational life sciences (Vol. 1). <a href="http://doi.org/10.1007/s12539-009-0016-2">http://doi.org/10.1007/s12539-009-0016-2</a> <a href="index.html#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Kipf, T. N., &amp; Welling, M. (2017). Semi-Supervised Classification with Graph Convolutional Networks. Proceedings of ICLR 2017. <a href="index.html#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>Yarowsky, D. (1995). Unsupervised word sense disambiguation rivaling supervised methods. In Proceedings of the 33rd annual meeting on Association for Computational Linguistics (pp. 189-196). Association for Computational Linguistics. <a href="index.html#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>McClosky, D., Charniak, E., &amp; Johnson, M. (2006). Effective self-training for parsing. Proceedings of the Main Conference on Human Language Technology Conference of the North American Chapter of the Association of Computational Linguistics, 152–159. <a href="index.html#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>Reichart, R., &amp; Rappoport, A. (2007). Self-training for enhancement and domain adaptation of statistical parsers trained on small datasets. In Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics (pp. 616-623) <a href="index.html#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>Huang, Z., &amp; Harper, M. (2009). Self-training PCFG grammars with latent annotations across languages. In Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing: Volume 2-Volume 2 (pp. 832-841). Association for Computational Linguistics. <a href="index.html#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>Suzuki, J., &amp; Isozaki, H. (2008). Semi-supervised sequential labeling and segmentation using giga-word scale unlabeled data. Proceedings of ACL-08: HLT, 665-673. <a href="index.html#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>Petrov, S., &amp; McDonald, R. (2012). Overview of the 2012 shared task on parsing the web. In Notes of the first workshop on syntactic analysis of non-canonical language (sancl) (Vol. 59). <a href="index.html#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>He, Y., &amp; Zhou, D. (2011). Self-training from labeled features for sentiment analysis. Information Processing &amp; Management, 47(4), 606-616. <a href="index.html#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>Plank, B. (2011). Domain adaptation for parsing. University Library Groniongen][Host]. <a href="index.html#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>Van Asch, V., &amp; Daelemans, W. (2016). Predicting the Effectiveness of Self-Training: Application to Sentiment Classification. arXiv preprint arXiv:1601.03288. <a href="index.html#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>van der Goot, R., Plank, B., &amp; Nissim, M. (2017). To normalize, or not to normalize: The impact of normalization on part-of-speech tagging. arXiv preprint arXiv:1707.05116. <a href="index.html#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>Blum, A., &amp; Mitchell, T. (1998). Combining labeled and unlabeled data with co-training. In Proceedings of the eleventh annual conference on Computational learning theory (pp. 92-100). ACM. <a href="index.html#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>Chen, M., Weinberger, K. Q., &amp; Chen, Y. (2011). Automatic Feature Decomposition for Single View Co-training. Proceedings of the 28th International Conference on Machine Learning (ICML-11), 953–960. <a href="index.html#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>Bousmalis, K., Trigeorgis, G., Silberman, N., Krishnan, D., &amp; Erhan, D. (2016). Domain Separation Networks. In Advances in Neural Information Processing Systems. <a href="index.html#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>Chen, M., Weinberger, K. Q., &amp; Blitzer, J. C. (2011). Co-Training for Domain Adaptation. In Advances in Neural Information Processing Systems. <a href="index.html#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>Zhou, Y., &amp; Goldman, S. (2004). Democratic Co-Learning. In 16th IEEE International Conference on Tools with Artificial Intelligence, ICTAI 2004. <a href="index.html#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>Zhou, Z.-H., &amp; Li, M. (2005). Tri-Training: Exploiting Unlabled Data Using Three Classifiers. IEEE Trans.Data Eng., 17(11), 1529–1541. <a href="http://doi.org/10.1109/TKDE.2005.186">http://doi.org/10.1109/TKDE.2005.186</a> <a href="index.html#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>Ruder, S., &amp; Plank, B. (2018). Strong Baselines for Neural Semi-supervised Learning under Domain Shift. In Proceedings of ACL 2018. <a href="index.html#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>Søgaard, A. (2010). Simple semi-supervised training of part-of-speech taggers. Proceedings of the ACL 2010 Conference Short Papers. <a href="index.html#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>Saito, K., Ushiku, Y., &amp; Harada, T. (2017). Asymmetric Tri-training for Unsupervised Domain Adaptation. In ICML 2017. Retrieved from <a href="http://arxiv.org/abs/1702.08400">http://arxiv.org/abs/1702.08400</a> <a href="index.html#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>Caruana, R. (1993). Multitask learning: A knowledge-based source of inductive bias. In Proceedings of the Tenth International Conference on Machine Learning. <a href="index.html#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>Rasmus, A., Valpola, H., Honkala, M., Berglund, M., &amp; Raiko, T. (2015). Semi-Supervised Learning with Ladder Network. arXiv Preprint arXiv:1507.02672. Retrieved from <a href="http://arxiv.org/abs/1507.02672">http://arxiv.org/abs/1507.02672</a> <a href="index.html#fnref24" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn25" class="footnote-item"><p>Miyato, T., Dai, A. M., &amp; Goodfellow, I. (2017). Adversarial Training Methods for Semi-supervised Text Classification. In Proceedings of ICLR 2017. <a href="index.html#fnref25" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn26" class="footnote-item"><p>Laine, S., &amp; Aila, T. (2017). Temporal Ensembling for Semi-Supervised Learning. In Proceedings of ICLR 2017. <a href="index.html#fnref26" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn27" class="footnote-item"><p>Kingma, D. P., &amp; Ba, J. L. (2015). Adam: a Method for Stochastic Optimization. International Conference on Learning Representations. <a href="index.html#fnref27" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn28" class="footnote-item"><p>Tarvainen, A., &amp; Valpola, H. (2017). Mean teachers are better role models: Weight-averaged consistency targets improve semi-supervised deep learning results. In Advances in Neural Information Processing Systems. Retrieved from <a href="http://arxiv.org/abs/1703.01780">http://arxiv.org/abs/1703.01780</a> <a href="index.html#fnref28" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn29" class="footnote-item"><p>Polyak, B. T., &amp; Juditsky, A. B. (1992). Acceleration of stochastic approximation by averaging. SIAM Journal on Control and Optimization, 30(4), 838-855. <a href="index.html#fnref29" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn30" class="footnote-item"><p>Oliver, A., Odena, A., Raffel, C., Cubuk, E. D., &amp; Goodfellow, I. J. (2018). Realistic Evaluation of Semi-Supervised Learning Algorithms. arXiv preprint arXiv:1804.09170. <a href="index.html#fnref30" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn31" class="footnote-item"><p>Hinton, G., Vinyals, O., &amp; Dean, J. (2015). Distilling the Knowledge in a Neural Network. arXiv Preprint arXiv:1503.02531. <a href="https://doi.org/10.1063/1.4931082">https://doi.org/10.1063/1.4931082</a> <a href="index.html#fnref31" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn32" class="footnote-item"><p>Kiritchenko, S., Zhu, X., &amp; Mohammad, S. M. (2014). Sentiment analysis of short informal texts. Journal of Artificial Intelligence Research, 50, 723-762. <a href="index.html#fnref32" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn33" class="footnote-item"><p>Dehghani, M., Mehrjou, A., Gouws, S., Kamps, J., &amp; Schölkopf, B. (2018). Fidelity-Weighted Learning. In Proceedings of ICLR 2018. Retrieved from <a href="http://arxiv.org/abs/1711.02799">http://arxiv.org/abs/1711.02799</a> <a href="index.html#fnref33" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn34" class="footnote-item"><p>Sukhbaatar, S., Bruna, J., Paluri, M., Bourdev, L., &amp; Fergus, R. (2015). Training Convolutional Networks with Noisy Labels. Workshop Track - ICLR 2015. Retrieved from <a href="http://arxiv.org/abs/1406.2080">http://arxiv.org/abs/1406.2080</a> <a href="index.html#fnref34" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn35" class="footnote-item"><p>Reed, S., Lee, H., Anguelov, D., Szegedy, C., Erhan, D., &amp; Rabinovich, A. (2015). Training Deep Neural Networks on Noisy Labels with Bootstrapping. ICLR 2015 Workshop Track. Retrieved from <a href="http://arxiv.org/abs/1412.6596">http://arxiv.org/abs/1412.6596</a> <a href="index.html#fnref35" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn36" class="footnote-item"><p>Zolna, K., Arpit, D., Suhubdy, D., &amp; Bengio, Y. (2018). Fraternal Dropout. In Proceedings of ICLR 2018. Retrieved from <a href="http://arxiv.org/abs/1711.00066">http://arxiv.org/abs/1711.00066</a> <a href="index.html#fnref36" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn37" class="footnote-item"><p>Yasunaga, M., Kasai, J., &amp; Radev, D. (2018). Robust Multilingual Part-of-Speech Tagging via Adversarial Training. In Proceedings of NAACL 2018. Retrieved from <a href="http://arxiv.org/abs/1711.04903">http://arxiv.org/abs/1711.04903</a> <a href="index.html#fnref37" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn38" class="footnote-item"><p>Sennrich, R., Haddow, B., &amp; Birch, A. (2016). Edinburgh neural machine translation systems for WMT 16. arXiv preprint arXiv:1606.02891. <a href="index.html#fnref38" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn39" class="footnote-item"><p>Huang, G., Li, Y., Pleiss, G., Liu, Z., Hopcroft, J. E., &amp; Weinberger, K. Q. (2017). Snapshot Ensembles: Train 1, get M for free. In Proceedings of ICLR 2017. <a href="index.html#fnref39" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
<!--kg-card-end: markdown-->
                </div>

<h2 id="citation">Newsletter</h2>

If you want to receive regular updates about advances in machine learning and natural language processing, then subscribe to <a href="https://newsletter.ruder.io/">my newsletter</a> below. 

<div id="revue-embed">
  <form action="http://newsletter.ruder.io/add_subscriber" method="post" id="revue-form" name="revue-form" $
  <div class="revue-form-group">
    <label for="member_email">Email address: </label>
    <input class="revue-form-field" placeholder="Your email address" type="email" name="member[email]" id="$
  </div>
  <div class="revue-form-group">
    <label for="member_first_name">First name <span class="optional">(Optional)</span>:</label>
    <input class="revue-form-field" placeholder="First name " type="text" name="member[first_name]" id="memb$
  </div>
  <div class="revue-form-group">
    <label for="member_last_name">Last name <span class="optional">(Optional)</span>:</label>
    <input class="revue-form-field" placeholder="Last name" type="text" name="member[last_name]" id="member$
  </div>
  <div class="revue-form-actions">
    <input type="submit" value="Subscribe" name="member[subscribe]" id="member_submit">
  </div>
  </form>
</div>

            </section>



        </article>

    </div>
</main>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = '/semi-supervised/';  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = "ghost-48"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://EXAMPLE.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            

<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
                <article class="read-next-card">
                    <header class="read-next-card-header">
                        <h3><span>More in</span> <a href="../tag/semi-supervised-learning/index.html">semi-supervised learning</a></h3>
                    </header>
                    <div class="read-next-card-content">
                        <ul>
                            <li>
                                <h4><a href="../10-exciting-ideas-of-2018-in-nlp/index.html">10 Exciting Ideas of 2018 in NLP</a></h4>
                                <div class="read-next-card-meta">
                                    <p><time datetime="2018-12-19">19 Dec 2018</time> –
                                        8 min read</p>
                                </div>
                            </li>
                        </ul>
                    </div>
                    <footer class="read-next-card-footer">
                        <a href="../tag/semi-supervised-learning/index.html">1 post
                            →</a>
                    </footer>
                </article>

                <article class="post-card post tag-natural-language-processing tag-events tag-reinforcement-learning tag-transfer-learning ">

    <a class="post-card-image-link" href="../highlights-naacl-2018/index.html">
        <img class="post-card-image"
            srcset="../content/images/size/w300/2018/06/IMG_20180603_183707_conference_venue.jpg 300w,
                   ../content/images/size/w600/2018/06/IMG_20180603_183707_conference_venue.jpgg 600w,
                  ../content/images/size/w1000/2018/06/IMG_20180603_183707_conference_venue.jpg 1000w,
                 ../content/images/size/w2000/2018/06/IMG_20180603_183707_conference_venue.jpg 2000w"
            sizes="(max-width: 1000px) 400px, 700px"
            src="../content/images/size/w600/2018/06/IMG_20180603_183707_conference_venue.jpg"
            alt="Highlights of NAACL-HLT 2018: Generalization, Test-of-time, and Dialogue Systems"
        />
    </a>

    <div class="post-card-content">

        <a class="post-card-content-link" href="../highlights-naacl-2018/index.html">

            <header class="post-card-header">
                    <div class="post-card-primary-tag">natural language processing</div>
                <h2 class="post-card-title">Highlights of NAACL-HLT 2018: Generalization, Test-of-time, and Dialogue Systems</h2>
            </header>

            <section class="post-card-excerpt">
                    <p>This post discusses highlights of the 16th Annual Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies (NAACL-HLT 2018). It focuses on Generalization, the Test-of-Time awards, and Dialogue Systems.</p>
            </section>

        </a>

        <footer class="post-card-meta">
            <ul class="author-list">
                <li class="author-list-item">
            
                    <div class="author-name-tooltip">
                        Sebastian Ruder
                    </div>
            
                    <a href="../author/sebastian/index.html" class="static-avatar">
                        <img class="author-profile-image" src="../content/images/size/w100/2019/02/new_profile_photo_square-1.jpg" alt="Sebastian Ruder" />
                    </a>
                </li>
            </ul>
            <div class="post-card-byline-content">
                <span><a href="../author/sebastian/index.html">Sebastian Ruder</a></span>
                <span class="post-card-byline-date"><time datetime="2018-06-12">12 Jun 2018</time> <span class="bull">&bull;</span> 15 min read</span>
            </div>
        </footer>

    </div>

</article>

                <article class="post-card post tag-tensorflow tag-natural-language-processing ">

    <a class="post-card-image-link" href="../text-classification-tensorflow-estimators/index.html">
        <img class="post-card-image"
            srcset="../content/images/size/w300/2018/10/estimators_loss.png 300w,
                   ../content/images/size/w600/2018/10/estimators_loss.png 600w,
                  ../content/images/size/w1000/2018/10/estimators_loss.png 1000w,
                 ../content/images/size/w2000/2018/10/estimators_loss.png 2000w"
            sizes="(max-width: 1000px) 400px, 700px"
            src="../content/images/size/w600/2018/10/estimators_loss.png"
            alt="Text Classification with TensorFlow Estimators"
        />
    </a>

    <div class="post-card-content">

        <a class="post-card-content-link" href="../text-classification-tensorflow-estimators/index.html">

            <header class="post-card-header">
                    <div class="post-card-primary-tag">tensorflow</div>
                <h2 class="post-card-title">Text Classification with TensorFlow Estimators</h2>
            </header>

            <section class="post-card-excerpt">
                    <p>This post is a tutorial that shows how to use Tensorflow Estimators for text classification. It covers loading data using Datasets, using pre-canned estimators as baselines, word embeddings, and building custom estimators, among others.</p>
            </section>

        </a>

        <footer class="post-card-meta">
            <ul class="author-list">
                <li class="author-list-item">
            
                    <div class="author-name-tooltip">
                        Sebastian Ruder
                    </div>
            
                    <a href="../author/sebastian/index.html" class="static-avatar">
                        <img class="author-profile-image" src="../content/images/size/w100/2019/02/new_profile_photo_square-1.jpg" alt="Sebastian Ruder" />
                    </a>
                </li>
            </ul>
            <div class="post-card-byline-content">
                <span><a href="../author/sebastian/index.html">Sebastian Ruder</a></span>
                <span class="post-card-byline-date"><time datetime="2018-04-16">16 Apr 2018</time> <span class="bull">&bull;</span> 13 min read</span>
            </div>
        </footer>

    </div>

</article>
        </div>
    </div>
</aside>




        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://ruder.io">Sebastian Ruder</a> &copy; 2021</section>
                <nav class="site-footer-nav">
                    <a href="https://ruder.io">Latest Posts</a>
                    
                    <a href="https://twitter.com/seb_ruder" target="_blank" rel="noopener">Twitter</a>
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>


    <script
        src="https://code.jquery.com/jquery-3.4.1.min.js"
        integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
        crossorigin="anonymous">
    </script>
    <script src="../assets/built/casper.js?v=fbdba21d16"></script>

    <script>
        // Parse the URL parameter
        function getParameterByName(name, url) {
            if (!url) url = window.location.href;
            name = name.replace(/[\[\]]/g, "\\$&");
            var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
                results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, " "));
        }

        // Give the parameter a variable name
        var action = getParameterByName('action');

        $(document).ready(function () {
            if (action == 'subscribe') {
                $('body').addClass("subscribe-success");
            }

            $('.subscribe-success-message .subscribe-close').click(function () {
                $('.subscribe-success-message').addClass('close');
            });

            // Reset form on opening subscrion overlay
            $('.subscribe-button').click(function() {
                $('.subscribe-overlay form').removeClass();
                $('.subscribe-email').val('');
            });
        });
    </script>

    <script>
    $(document).ready(function () {
        // FitVids - start
        var $postContent = $(".post-full-content");
        $postContent.fitVids();
        // FitVids - end

        // Replace nav with title on scroll - start
        Casper.stickyNavTitle({
            navSelector: '.site-nav-main',
            titleSelector: '.post-full-title',
            activeClass: 'nav-post-title-active'
        });
        // Replace nav with title on scroll - end

        // Hover on avatar
        var hoverTimeout;
        $('.author-list-item').hover(function () {
            var $this = $(this);

            clearTimeout(hoverTimeout);

            $('.author-card').removeClass('hovered');
            $(this).children('.author-card').addClass('hovered');

        }, function () {
            var $this = $(this);

            hoverTimeout = setTimeout(function () {
                $this.children('.author-card').removeClass('hovered');
            }, 800);
        });
    });
</script>


    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.1.6/zepto.min.js"></script>
<script>jQuery = Zepto</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/themes/prism.min.css" />
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/plugins/line-numbers/prism-line-numbers.min.css" />
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/themes/prism-coy.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-python.min.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-60512592-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-60512592-1');
</script>

</body>
</html>

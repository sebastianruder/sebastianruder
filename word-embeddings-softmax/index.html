<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <title>Approximating the Softmax for Learning Word Embeddings</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" type="text/css" href="../assets/built/screen.css?v=aa9afcc559" />

    <meta name="description" content="This blog post gives an overview of softmax-based and sampling-based approaches that approximate the softmax layer for learning word embeddings." />
    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" />
    <link rel="canonical" href="https://ruder.io/word-embeddings-softmax/" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    <link rel="amphtml" href="https://ruder.io/word-embeddings-softmax/amp/" />
    
    <meta property="og:site_name" content="Sebastian Ruder" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Approximating the Softmax for Learning Word Embeddings" />
    <meta property="og:description" content="The softmax layer is a core part of many current neural network architectures. When the number of output classes is very large, such as in the case of language modelling, computing the softmax becomes very expensive. This post explores approximations to make the computation more efficient." />
    <meta property="og:url" content="https://ruder.io/word-embeddings-softmax/" />
    <meta property="og:image" content="https://ruder.io/content/images/2016/06/softmax_classifier.png" />
    <meta property="article:published_time" content="2016-06-13T10:00:00.000Z" />
    <meta property="article:modified_time" content="2020-06-15T11:27:33.000Z" />
    <meta property="article:tag" content="word embeddings" />
    <meta property="article:tag" content="natural language processing" />
    <meta property="article:tag" content="language models" />
    
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Approximating the Softmax for Learning Word Embeddings" />
    <meta name="twitter:description" content="The softmax layer is a core part of many current neural network architectures. When the number of output classes is very large, such as in the case of language modelling, computing the softmax becomes very expensive. This post explores approximations to make the computation more efficient." />
    <meta name="twitter:url" content="https://ruder.io/word-embeddings-softmax/" />
    <meta name="twitter:image" content="https://ruder.io/content/images/2016/06/softmax_classifier.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Sebastian Ruder" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="word embeddings, natural language processing, language models" />
    <meta name="twitter:site" content="@seb_ruder" />
    <meta property="og:image:width" content="875" />
    <meta property="og:image:height" content="643" />
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Sebastian Ruder",
        "url": "https://ruder.io/",
        "logo": {
            "@type": "ImageObject",
            "url": {
                "@type": "ImageObject",
                "url": "https://ruder.io/favicon.ico",
                "width": 48,
                "height": 48
            }
        }
    },
    "author": {
        "@type": "Person",
        "name": "Sebastian Ruder",
        "image": {
            "@type": "ImageObject",
            "url": "https://ruder.io/content/images/2019/02/new_profile_photo_square-1.jpg",
            "width": 2000,
            "height": 2000
        },
        "url": "https://ruder.io/author/sebastian/",
        "sameAs": []
    },
    "headline": "Approximating the Softmax for Learning Word Embeddings",
    "url": "https://ruder.io/word-embeddings-softmax/",
    "datePublished": "2016-06-13T10:00:00.000Z",
    "dateModified": "2020-06-15T11:27:33.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "https://ruder.io/content/images/2016/06/softmax_classifier.png",
        "width": 875,
        "height": 643
    },
    "keywords": "word embeddings, natural language processing, language models",
    "description": "The softmax layer is a core part of many current neural network architectures. When the number of output classes is very large, such as in the case of language modelling, computing the softmax becomes very expensive. This post explores approximations to make the computation more efficient.",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://ruder.io/"
    }
}
    </script>

    <meta name="generator" content="Ghost 3.11" />
    <link rel="alternate" type="application/rss+xml" title="Sebastian Ruder" href="https://ruder.io/rss/" />
    <script>
var profile_title = 'Sebastian Ruder';
</script>
<script>
var disqus_shortname = 'sebastianruder';
</script>
<script>
var profile_resume ='NLP PhD student';
</script>
<script>
var ga_id = 'UA-60512592-1';
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [["$", "$"], ["\\(", "\\)"]],
        processEscapes: true
    }
});
</script>

</head>
<body class="post-template tag-word-embeddings tag-natural-language-processing tag-language-models">

    <div class="site-wrapper">

        

<header class="site-header">
    <div class="outer site-nav-main">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left-wrapper">
        <div class="site-nav-left">
                <a class="site-nav-logo" href="https://ruder.io">Sebastian Ruder</a>
            <div class="site-nav-content">
                    <ul class="nav" role="menu">
    <li class="nav-about" role="menuitem"><a href="https://ruder.io/about/">About</a></li>
    <li class="nav-tags" role="menuitem"><a href="https://ruder.io/tags/">Tags</a></li>
    <li class="nav-papers" role="menuitem"><a href="https://ruder.io/publications/">Papers</a></li>
    <li class="nav-talks" role="menuitem"><a href="https://ruder.io/talks/">Talks</a></li>
    <li class="nav-news" role="menuitem"><a href="https://ruder.io/news/">News</a></li>
    <li class="nav-faq" role="menuitem"><a href="https://ruder.io/faq/">FAQ</a></li>
    <li class="nav-newsletter" role="menuitem"><a href="https://ruder.io/nlp-news/">Newsletter</a></li>
    <li class="nav-nlp-progress" role="menuitem"><a href="https://nlpprogress.com/">NLP Progress</a></li>
    <li class="nav-media" role="menuitem"><a href="https://ruder.io/media/">Media</a></li>
    <li class="nav-contact" role="menuitem"><a href="https://ruder.io/contact/">Contact</a></li>
</ul>

                    <span class="nav-post-title dash">On word embeddings - Part 2: Approximating the Softmax</span>
            </div>
        </div>
    </div>
    <div class="site-nav-right">
            <div class="social-links">
                    <a class="social-link social-link-tw" href="https://twitter.com/seb_ruder" title="Twitter" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>
</a>
            </div>
                <a class="rss-button" href="https://ruder.io/rss/index.rss" title="RSS" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="6.18" cy="17.82" r="2.18"/><path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/></svg>
</a>

    </div>
</nav>
    </div>
</div></header>


<main id="site-main" class="site-main outer">
    <div class="inner">

        <article class="post-full post tag-word-embeddings tag-natural-language-processing tag-language-models ">

            <header class="post-full-header">

                <section class="post-full-tags">
                    <a href="../tag/word-embeddings/index.html">word embeddings</a>
                </section>

                <h1 class="post-full-title">On word embeddings - Part 2: Approximating the Softmax</h1>

                <p class="post-full-custom-excerpt">The softmax layer is a core part of many current neural network architectures. When the number of output classes is very large, such as in the case of language modelling, computing the softmax becomes very expensive. This post explores approximations to make the computation more efficient.</p>

                <div class="post-full-byline">

                    <section class="post-full-byline-content">

                        <ul class="author-list">
                            <li class="author-list-item">

                                <div class="author-card">
                                    <img class="author-profile-image" src="../content/images/size/w100/2019/02/new_profile_photo_square-1.jpg" alt="Sebastian Ruder" />
                                    <div class="author-info">
                                        <h2>Sebastian Ruder</h2>
                                        <p>Read <a href="../author/sebastian/index.html">more posts</a> by this author.</p>
                                    </div>
                                </div>

                                <a href="../author/sebastian/index.html" class="author-avatar">
                                    <img class="author-profile-image" src="../content/images/size/w100/2019/02/new_profile_photo_square-1.jpg" alt="Sebastian Ruder" />
                                </a>

                            </li>
                        </ul>

                        <section class="post-full-byline-meta">
                            <h4 class="author-name"><a href="../author/sebastian/index.html">Sebastian Ruder</a></h4>
                            <div class="byline-meta-content">
                                <time class="byline-meta-date" datetime="2016-06-13">13 Jun 2016</time>
                                <span class="byline-reading-time"><span class="bull">&bull;</span> 33 min read</span>
                            </div>
                        </section>

                    </section>


                </div>
            </header>

            <figure class="post-full-image">
                <img
                    srcset="../content/images/size/w300/2016/06/softmax_classifier.png 300w,
                           ../content/images/size/w600/2016/06/softmax_classifier.png 600w,
                          ../content/images/size/w1000/2016/06/softmax_classifier.png 1000w,
                         ../content/images/size/w2000/2016/06/softmax_classifier.png 2000w"
                    sizes="(max-width: 800px) 400px,
                        (max-width: 1170px) 1170px,
                            2000px"
                    src="../content/images/size/w2000/2016/06/softmax_classifier.png"
                    alt="On word embeddings - Part 2: Approximating the Softmax"
                />
            </figure>

            <section class="post-full-content">
                <div class="post-content">
                    <!--kg-card-begin: markdown--><p>This post gives an overview of approximations that can be used to make the expensive softmax layer more efficient.</p>
<p>Table of contents:</p>
<ul>
<li><a href="index.html#softmaxarchitecturemodifications">Softmax-based Approaches</a>
<ul>
<li><a href="index.html#hierarchicalsoftmax">Hierarchical Softmax</a></li>
<li><a href="index.html#differentiatedsoftmax">Differentiated Softmax</a></li>
<li><a href="index.html#cnnsoftmax">CNN-Softmax</a></li>
</ul>
</li>
<li><a href="index.html#samplingbasedapproaches">Sampling-based Approaches</a>
<ul>
<li><a href="index.html#importancesampling">Importance Sampling</a></li>
<li><a href="index.html#adaptiveimportancesampling">Adaptive Importance Sampling</a></li>
<li><a href="index.html#targetsampling">Target Sampling</a></li>
<li><a href="index.html#noisecontrastiveestimation">Noise Contrastive Estimation</a></li>
<li><a href="index.html#negativesampling">Negative Sampling</a></li>
<li><a href="index.html#selfnormalisation">Self-Normalisation</a></li>
<li><a href="index.html#infrequentnormalisation">Infrequent Normalisation</a></li>
<li><a href="index.html#otherapproaches">Other Approaches</a></li>
</ul>
</li>
<li><a href="index.html#whichapproachtochoose">Which Approach to Choose?</a></li>
<li><a href="index.html#conclusion">Conclusion</a></li>
</ul>
<p>This is the second post in a series on word embeddings and representation learning. In the <a href="http://ruder.io/word-embeddings-1/index.html">previous post</a>, we gave an overview of word embedding models and introduced the classic neural language model by Bengio et al. (2003), the C&amp;W model by Collobert and Weston (2008), and the word2vec model by Mikolov et al. (2013). We observed that mitigating the complexity of computing the final softmax layer has been one of the main challenges in devising better word embedding models, a commonality with machine translation (MT) (Jean et al., 2015) <sup class="footnote-ref"><a href="index.html#fn1" id="fnref1">[1]</a></sup> and language modelling (Jozefowicz et al., 2016) <sup class="footnote-ref"><a href="index.html#fn2" id="fnref2">[2]</a></sup>.</p>
<p>In this post, we will thus focus on giving an overview of various approximations to the softmax layer that have been proposed over the last years, some of which have so far only been employed in the context of language modelling or MT. We will postpone the discussion of additional hyperparameters to the subsequent post.</p>
<p>Let us know partially re-introduce the previous post's notation both for consistency and to facilitate comparison as well as introduce some new notation: We assume a training corpus containing a sequence of \(T\) training words \(w_1, w_2, w_3, \cdots, w_T\) that belong to a vocabulary \(V\) whose size is \(|V|\). Our models generally consider a context \(c\) of \( n \) words. We associate every word with an input embedding \( v_w \) (the eponymous word embedding in the Embedding Layer) with \(d\) dimensions and an output embedding \( v'_w \) (the representation of the word in the weight matrix of the softmax layer). We finally optimize an objective function \(J_\theta\) with regard to our model parameters \(\theta\).</p>
<p>Recall that the softmax calculates the probability of a word \(w\) given its context \(c\) and can be computed using the following equation:</p>
<p>\(p(w | c) = \dfrac{\text{exp}({h^\top v'_w})}{\sum_{w_i \in V} \text{exp}({h^\top v'_{w_i}})} \)</p>
<p>where \(h\) is the output vector of the penultimate network layer. Note that we use \(c\) for the context as mentioned above and drop the index \(t\) of the target word \(w_t\) for simplicity. Computing the softmax is expensive as the inner product between \(h\) and the output embedding of every word \(w_i\) in the vocabulary \(V\) needs to be computed as part of the sum in the denominator in order to obtain the normalized probability of the target word \(w\) given its context \(c\).</p>
<p>In the following we will discuss different strategies that have been proposed to approximate the softmax. These approaches can be grouped into softmax-based and sampling-based approaches. Softmax-based approaches are methods that keep the softmax layer intact, but modify its architecture to improve its efficiency. Sampling-based approaches on the other hand completely do away with the softmax layer and instead optimise some other loss function that approximates the softmax.</p>
<h1 id="softmaxbasedapproaches">Softmax-based Approaches</h1>
<h2 id="hierarchicalsoftmax">Hierarchical Softmax</h2>
<p>Hierarchical softmax (H-Softmax) is an approximation inspired by binary trees that was proposed by Morin and Bengio (2005) <sup class="footnote-ref"><a href="index.html#fn3" id="fnref3">[3]</a></sup>. H-Softmax essentially replaces the flat softmax layer with a hierarchical layer that has the words as leaves, as can be seen in Figure 1.<br>
This allows us to decompose calculating the probability of one word into a sequence of probability calculations, which saves us from having to calculate the expensive normalization over all words. Replacing a softmax layer with H-Softmax can yield speedups for word prediction tasks of at least \(50 \times\) and is thus critical for low-latency tasks such as real-time communication in <a href="http://googleresearch.blogspot.ie/2016/05/chat-smarter-with-allo.html">Google's new messenger app Allo</a>.</p>
<figure>
      <img src="https://ruder.io/content/images/2016/06/hierarchical_softmax_example.png" style="width: 70%" title="Hierarchical softmax">
<figcaption>Figure 1: Hierarchical softmax (<a href="https://www.quora.com/Word2vec-How-can-hierarchical-soft-max-training-method-of-CBOW-guarantee-its-self-consistence">Quora</a>)</figcaption>
</figure>
<p>We can think of the regular softmax as a tree of depth \(1\), with each word in \(V\) as a leaf node.  Computing the softmax probability of one word then requires normalizing over the probabilities of all \(|V|\) leaves. If we instead structure the softmax as a binary tree, with the words as leaf nodes, then we only need to follow the path to the leaf node of that word, without having to consider any of the other nodes.<br>
Since a balanced binary tree has a depth of \(\text{log}_2 (|V|)\), we only need to evaluate at most \(\text{log}_2 (|V|)\) nodes to obtain the final probability of a word. Note that this probability is already normalized, as the probabilities of all leaves in a binary tree sum to \( 1 \) and thus form a probability distribution. To informally verify this, we can reason that at a tree's root node (Node 0) in Figure 1), the probabilities of branching decisions must sum to \(1\). At each subsequent node, the probability mass is then split among its children, until it eventually ends up at the leaf nodes, i.e. the words. Since no probability is lost along the way and since all words are leaves, the probabilities of all words must necessarily sum to \(1\) and hence the hierarchical softmax defines a normalized probability distribution over all words in \(V\).</p>
<p>To get a bit more concrete, as we go through the tree, we have to be able to calculate the probability of taking the left or right branch at every junction. For this reason, we assign a representation to every node. In contrast to the regular softmax, we thus no longer have output embeddings \(v'_w\) for every word \(w\) -- instead, we have embeddings \(v'_n\) for every node \(n\). As we have \(|V|-1\) nodes and each one possesses a unique representation, the number of parameters of H-Softmax is almost the same as for the regular softmax. We can now calculate the probability of going right (or left) at a given node \(n\) given the context \(c\) the following way:</p>
<p>\( p(\text{right} | n, c) = \sigma (h^\top v'_{n})\).</p>
<p>This is almost the same as the computations in the regular softmax; now instead of computing the dot product between \(h\) and the output word embedding \(v'_{w}\), we compute the dot product between \(h\) and the embedding \(v'_{w}\) of each node in the tree; additionally, instead of computing a probability distribution over the entire vocabulary words, we output just one probability, the probability of going right at node \(n\) in this case, with the sigmoid function. Conversely, the probability of turning left is simply \( 1 - p(  \text{right}   |    n,c)\).</p>
<figure>
      <img src="https://ruder.io/content/images/2016/05/hierarchical_softmax.png" style="width: 70%" title="Hierarchical softmax">
<figcaption>Figure 2: Hierarchical softmax computations (<a href="https://www.youtube.com/watch?v=B95LTf2rVWM">Hugo Lachorelle's Youtube lectures</a>)</figcaption>
</figure>
<p>The probability of a word \(w\) given its context \(c\) is then simply the product of the probabilities of taking right and left turns respectively that lead to its leaf node. To illustrate this, given the context &quot;the&quot;, &quot;dog&quot;, &quot;and&quot;, &quot;the&quot;, the probability of the word &quot;cat&quot; in Figure 2 can be computed as the product of the probability of turning left at node 1, turning right at node 2, and turning right at node 5. Hugo Lachorelle gives a more detailed account in his excellent <a href="https://www.youtube.com/watch?v=B95LTf2rVWM">lecture video</a>. Rong (2014) <sup class="footnote-ref"><a href="index.html#fn4" id="fnref4">[4]</a></sup> also does a good job of explaining these concepts and also derives the derivatives of H-Softmax.</p>
<p>Obviously, the structure of the tree is of significance. Intuitively, we should be able to achieve better performance, if we make it easier for the model to learn the binary predictors at every node, e.g. by enabling it to assign similar probabilities to similar paths. Based on this idea, Morin and Bengio use the synsets in WordNet as clusters for the tree. However, they still report inferior performance to the regular softmax. Mnih and Hinton (2008) <sup class="footnote-ref"><a href="index.html#fn5" id="fnref5">[5]</a></sup> learn the tree structure with a clustering algorithm that recursively partitions the words in two clusters and allows them to achieve the same performance as the regular softmax at a fraction of the computation.</p>
<p>Notably, we are only able to obtain this speed-up during training, when we know the word we want to predict (and consequently its path) in advance. During testing, when we need to find the most likely prediction, we still need to calculate the probability of all words, although narrowing down the choices in advance helps here.</p>
<p>In practice, instead of using &quot;right&quot; and &quot;left&quot; in order to designate nodes, we can index every node with a bit vector that corresponds to the path it takes to reach that node. In Figure 2, if we assume a <code class="language-python">0</code> bit for turning left and a <code class="language-python">1</code> bit for turning right, we can thus represent the path to &quot;cat&quot; as <code class="language-python">011</code>.<br>
Recall that the path length in a balanced binary tree is \(\text{log}_2 |V|\). If we set \(|V| = 10000\), this amounts to an average path length of about \( 13.3 \). Analogously, we can represent every word by the bit vector of its path that is on average \(13.3\) bits long. In information theory, this is referred to as an  information content of \(13.3\) bits per word.</p>
<h3 id="anoteontheinformationcontentofwords">A note on the information content of words</h3>
<p>Recall that the information content \(I(w)\) of a word \(w\) is the negative logarithm of its probability \(p(w)\):</p>
<p>\(I(w) = -\log_2 p(w) \).</p>
<p>The entropy \( H \) of all words in a corpus is then the expectation of the information content of all words in the vocabulary:</p>
<p>\( H = \sum_{i\in V} p(w_i)    I(w_i) \).</p>
<p>We can also conceive of the entropy of a data source as the average number of bits needed to encode it. For a fair coin flip, we need \(1\) bit per flip, whereas we need \(0\) bits for a data source that always emits the same symbol. For a balanced binary tree, where we treat every word equally, the word entropy \(H\) equals the information content \(I(w)\) of every word \(w\), as each word has the same probability. The average word entropy \(H\) in a balanced binary tree with \(|V| = 10000\) thus coincides with its average path length:</p>
<p>\( H = - \sum_{i\in V} \dfrac{1}{10000} \log_2  \dfrac{1}{10000} = 13.3\).</p>
<p>We saw before that the structure of the tree is important. Notably, we can leverage the tree structure not only to gain better performance, but also to speed up computation: If we manage to encode more information into the tree, we can get away with taking shorter paths for less informative words. Morin and Bengio point out that leveraging word probabilities should work even better; as some words are more likely to occur than others, they can be encoded using less information. They note that the word entropy of their corpus (with \(|V| = 10,000\)) is about \( 9.16 \).</p>
<p>Thus, by taking into account frequencies, we can reduce the average number of bits per word in the corpus from \( 13.3 \) to \( 9.16 \) in this case, which amounts to a speed-up of 31%. A <a href="https://en.wikipedia.org/wiki/Huffman_coding">Huffman tree</a>, which is used by Mikolov et al. (2013) <sup class="footnote-ref"><a href="index.html#fn6" id="fnref6">[6]</a></sup> for their hierarchical softmax, generates such a coding by assigning fewer bits to more common symbols. For instance, &quot;the&quot;, the most common word in the English language, would be assigned the shortest bit code in the tree, the second most frequent word would be assigned the second-shortest bit code, and so on. While we still need the same number of codes to designate all words, when we predict the words in a corpus, short codes appear now a lot more often, and we consequently need fewer bits to represent each word on average.</p>
<p>A coding such as Huffman coding is also known as entropy encoding, as the length of each codeword is approximately proportional to the entropy of each symbol as we have observed. Shannon (1951) <sup class="footnote-ref"><a href="index.html#fn7" id="fnref7">[7]</a></sup> establishes in his experiments that the lower bound on the information rate in English is between \(0.6\) to \(1.3\) bits per character; given an average word length of \(4.5\), this amounts to \(2.7\) - \(5.85\) bits per word.</p>
<p>To tie this back to language modelling (which we already talked about in the previous post): perplexity, the evaluation measure of language modelling, is \(2^{H}\) where \(H\) is the entropy. A unigram entropy of \( 9.16 \) thus entails a still very high perplexity of \( 2^{9.16} = 572.0\). We can render this value more tangible by observing that a model with a perplexity of \(572\) is as confused by the data as if it had to choose among \(572\) possibilities for each word uniformly and independently.</p>
<p>To put this into context: The state-of-the-art language model by Jozefowicz et al. (2016) achieves a perplexity of \(24.2\) per word on the 1B Word Benchmark. Such a model would thus require an average of around \(4.60\) bits to encode each word, as \( 2^{4.60} = 24.2 \), which is incredibly close to the experimental lower bounds documented by Shannon. If and how we could use such a model to construct a better hierarchical softmax layer is still left to be explored.</p>
<h2 id="differentiatedsoftmax">Differentiated Softmax</h2>
<p>Chen et al. (2015) <sup class="footnote-ref"><a href="index.html#fn8" id="fnref8">[8]</a></sup> introduce a variation on the traditional softmax layer, the Differentiated Softmax (D-Softmax). D-Softmax is based on the intuition that not all words require the same number of parameters: Many occurrences of frequent words allow us to fit many parameters to them, while extremely rare words might only allow to fit a few.</p>
<p>In order to do this, instead of the dense matrix of the regular softmax layer of size \(d    \times    |V| \) containing the output word embeddings \( v'_w \in \mathbb{R}^d \), they use a sparse matrix. They then arrange \( v'_w\) in blocks sorted by frequency, with the embeddings in each block being of a certain dimensionality \(d_k \). The number of blocks and their embedding sizes are hyperparameters that can be tuned.</p>
<figure>
      <img src="https://ruder.io/content/images/2016/05/differentiated_softmax_1.png" style="width: 30%" title="Differentiated softmax">
<figcaption>Figure 3: Differentiated softmax (Chen et al. (2015))</figcaption>
</figure>
<p>In Figure 3, embeddings in partition \(A\) are of dimensionality \(d_A\) (these are embeddings of frequent words, as they are allocated more parameters), while embeddings in partitions \(B\) and \(C\) have \(d_B\) and \(d_C\) dimensions respectively. Note that all areas not part of any partition, i.e. the non-shaded areas in Figure 1, are set to \(0\).</p>
<p>The output of the previous hidden layer \(h\) is treated as a concatenation of features corresponding to each partition of the dimensionality of that partition, e.g. \(h\) in Figure 3 is made up of partitions of size \(d_A\), \(d_B\), and \(d_B\) respectively. Instead of computing the matrix-vector product between the entire output embedding matrix and \(h\) as in the regular softmax, D-Softmax then computes the product of each partition and its corresponding section in \(h\).</p>
<p>As many words will only require comparatively few parameters, the complexity of computing the softmax is reduced, which speeds up training. In contrast to H-Softmax, this speed-up persists during testing. Chen et al. (2015) observe that D-Softmax is the fastest method when testing, while being one of the most accurate. However, as it assigns fewer parameters to rare words, D-Softmax does a worse job at modelling them.</p>
<h2 id="cnnsoftmax">CNN-Softmax</h2>
<p>Another modification to the traditional softmax layer is inspired by recent work by Kim et al. (2016) <sup class="footnote-ref"><a href="index.html#fn9" id="fnref9">[9]</a></sup> who produce input word embeddings \(v_w\) via a character-level CNN. Jozefowicz et al. (2016) in turn suggest to do the same thing for the output word embeddings \(v'_w\) via a character-level CNN -- and refer to this as CNN-Softmax. Note that if we have a CNN at the input and at the output as in Figure 4, the CNN generating the output word embeddings \(v'_w\) is necessarily different from the CNN generating the input word embeddings \(v_w\), just as the input and output word embedding matrices would be different.</p>
<figure>
      <img src="https://ruder.io/content/images/2016/05/cnn-softmax_1.png" style="width: 30%" title="CNN-Softmax">
<figcaption>Figure 4: CNN-Softmax (Jozefowicz et al. (2016))</figcaption>
</figure>
<p>While this still requires computing the regular softmax normalization, this approach drastically reduces the number of parameters of the model: Instead of storing an embedding matrix of \(d    \times    |V| \), we now only need to keep track of the parameters of the CNN. During testing, the output word embeddings \(v'_w\) can be pre-computed, so that there is no loss in performance.</p>
<p>However, as characters are represented in a continuous space and as the resulting model tends to learn a smooth function mapping characters to a word embedding, character-based models often find it difficult to differentiate between similarly spelled words with different meanings. To mitigate this, the authors add a correction factor that is learned per word, which significantly reduces the performance gap between regular and CNN-softmax. By adjusting the dimensionality of the correction term, the authors are able to trade-off model size versus performance.</p>
<p>The authors also note that instead of using a CNN-softmax, the output of the previous layer \(h\) can be fed to a character-level LSTM, which predicts the output word one character at a time. Instead of a softmax over words, a softmax outputting a probability distribution over characters would thus be used at every time step. They, however, fail to achieve competitive performance with this layer. Ling et al. (2016) <sup class="footnote-ref"><a href="index.html#fn10" id="fnref10">[10]</a></sup> use a similar layer for machine translation and achieve competitive results.</p>
<h1 id="samplingbasedapproaches">Sampling-based Approaches</h1>
<p>While the approaches discussed so far still maintain the overall structure of the softmax, sampling-based approaches on the other hand completely do away with the softmax layer. They do this by approximating the normalization in the denominator of the softmax with some other loss that is cheap to compute. However, sampling-based approaches are only useful at training time -- during inference, the full softmax still needs to be computed to obtain a normalised probability.</p>
<p>In order to gain some intuitions about the softmax denominator's impact on the loss, we will derive the gradient of our loss function \(J_\theta\) w.r.t. the parameters of our model \(\theta\).<br>
During training, we aim to minimize the cross-entropy loss of our model for every word \(w\) in the training set. This is simply the negative logarithm of the output of our softmax. If you are unsure of this connection, have a look at <a href="http://cs231n.github.io/linear-classify/#softmax-classifier">Karpathy's explanation</a> to gain some more intuitions about the connection between softmax and cross-entropy. The loss of our model is then the following:</p>
<p>\(J_\theta = -    \text{log}    \dfrac{\text{exp}({h^\top v'_{w}})}{\sum_{w_i \in V} \text{exp}({h^\top v'_{w_i}})} \).</p>
<p>Note that in practice \(J_\theta\) would be the average of all negative log-probabilities over the whole corpus. To facilitate the derivation, we decompose \(J_\theta \) into a sum as \(\text{log}    \dfrac{x}{y} = \text{log}    x - \text{log}    y \):</p>
<p>\(J_\theta = -    h^\top v'_{w} + \text{log} \sum_{w_i \in V} \text{exp}(h^\top v'_{w_i}) \)</p>
<p>For brevity and to conform with the notation of  Bengio and Senécal (2003; 2008) <sup class="footnote-ref"><a href="index.html#fn11" id="fnref11">[11]</a></sup>, <sup class="footnote-ref"><a href="index.html#fn12" id="fnref12">[12]</a></sup> (note that in the first paper, they compute the gradient of the <em>positive</em> logarithm), we replace the dot product \( h^\top v'_{w} \) with \( - \mathcal{E}(w) \). Our loss then looks like the following:</p>
<p>\(J_\theta =    \mathcal{E}(w) + \text{log} \sum_{w_i \in V} \text{exp}( - \mathcal{E}(w_i)) \)</p>
<p>For back-propagation, we can now compute the gradient \(\nabla \) of \(J_\theta \) w.r.t. our model's parameters \(\theta\):</p>
<p>\(\nabla_\theta J_\theta =    \nabla_\theta \mathcal{E}(w)  + \nabla_\theta \text{log} \sum_{w_i \in V} \text{exp}(- \mathcal{E}(w_i)) \)</p>
<p>As the gradient of \( \text{log}    x \) is \(\dfrac{1}{x} \), an application of the chain rule yields:</p>
<p>\(\nabla_\theta J_\theta =    \nabla_\theta \mathcal{E}(w) + \dfrac{1}{\sum_{w_i \in V} \text{exp}(- \mathcal{E}(w_i))} \nabla_\theta \sum_{w_i \in V} \text{exp}(- \mathcal{E}(w_i) \)</p>
<p>We can now move the gradient inside the sum:</p>
<p>\(\nabla_\theta J_\theta =    \nabla_\theta \mathcal{E}(w)  + \dfrac{1}{\sum_{w_i \in V} \text{exp}(- \mathcal{E}(w_i))} \sum_{w_i \in V} \nabla_\theta    \text{exp}(- \mathcal{E}(w_i)) \)</p>
<p>As the gradient of \(\text{exp}(x)\) is just \(\text{exp}(x)\), another application of the chain rule yields:</p>
<p>\(\nabla_\theta J_\theta = \nabla_\theta \mathcal{E}(w) + \dfrac{1}{\sum_{w_i \in V} \text{exp}(- \mathcal{E}(w_i))} \sum_{w_i \in V} \text{exp}(- \mathcal{E}(w_i)) \nabla_\theta (- \mathcal{E}(w_i)) \)</p>
<p>We can rewrite this as:</p>
<p>\(\nabla_\theta J_\theta = \nabla_\theta \mathcal{E}(w) + \sum_{w_i \in V} \dfrac{\text{exp}(- \mathcal{E}(w_i))}{\sum_{w_i \in V} \text{exp}(- \mathcal{E}(w_i))} \nabla_\theta (- \mathcal{E}(w_i)) \)</p>
<p>Note that \( \dfrac{\text{exp}(- \mathcal{E}(w_i))}{\sum_{w_i \in V} \text{exp}(- \mathcal{E}(w_i))} \) is just the softmax probability \(P(w_i) \) of \(w_i\) (we omit the dependence on the context \(c\) here for brevity). Replacing it yields:</p>
<p>\(\nabla_\theta J_\theta = \nabla_\theta \mathcal{E}(w) + \sum_{w_i \in V} P(w_i) \nabla_\theta (- \mathcal{E}(w_i)) \)</p>
<p>Finally, repositioning the negative coefficient in front of the sum yields:</p>
<p>\(\nabla_\theta J_\theta =    \nabla_\theta \mathcal{E}(w) - \sum_{w_i \in V} P(w_i) \nabla_\theta \mathcal{E}(w_i) \)</p>
<p>Bengio and Senécal (2003) note that the gradient essentially has two parts: a positive reinforcement for the target word \(w\) (the first term in the above equation) and a negative reinforcement for all other words \(w_i\), which is weighted by their probability (the second term). As we can see, this negative reinforcement is just the expectation \(\mathbb{E}_{w_i \sim P}\) of the gradient of \(\mathcal{E} \) for all words \(w_i\) in \(V\):</p>
<p>\(\sum_{w_i \in V} P(w_i) \nabla_\theta \mathcal{E}(w_i) =  \mathbb{E}_{w_i \sim P}[\nabla_\theta \mathcal{E}(w_i)]\).</p>
<p>The crux of most sampling-based approach now is to approximate this negative reinforcement in some way to make it easier to compute, since we don't want to sum over the probabilities for all words in \(V\).</p>
<h2 id="importancesampling">Importance Sampling</h2>
<p>We can approximate the expected value \(\mathbb{E}\) of any probability distribution using the Monte Carlo method, i.e. by taking the mean of random samples of the probability distribution. If we knew the network's distribution, i.e. \(P(w)\), we could thus directly sample \(m\) words \( w_1 , \cdots , w_m \) from it and approximate the above expectation with:</p>
<p>\( \mathbb{E}_{w_i \sim P}[\nabla_\theta \mathcal{E}(w_i)] \approx \dfrac{1}{m} \sum\limits^m_{i=1} \nabla_\theta \mathcal{E}(w_i) \).</p>
<p>However, in order to sample from the probability distribution \( P \), we need to compute \( P \), which is just what we wanted to avoid in the first place. We therefore have find some other distribution \( Q \) (we call this the proposal distribution), from which it is cheap to sample and which can be used as the basis of Monte-Carlo sampling. Preferably, \(Q\) should also be similar to \(P\), since we want our approximated expectation to be as accurate as possible. A straightforward choice in the case of language modelling is to simply use the unigram distribution of the training set for \( Q \).</p>
<p>This is essentially what classical Importance Sampling (IS) does: It uses Monte-Carlo sampling to approximate a target distribution \(P\) via a proposal distribution \(Q\). However, this still requires computing \(P(w)\) for every word \(w\) that is sampled. To avoid this, Bengio and Senécal (2003) use a biased estimator that was first proposed by Liu (2001) <sup class="footnote-ref"><a href="index.html#fn13" id="fnref13">[13]</a></sup>. This estimator can be used when \( P(w) \) is computed as a product, which is the case here, since every division can be transformed into a multiplication.<br>
Essentially, instead of weighting the gradient \(\nabla_\theta \mathcal{E}(w_i)\) with the expensive to compute probability \(P_{w_i}\), we weight it with a factor that leverages the proposal distribution \(Q\). For biased IS, this factor is \(\dfrac{1}{R}r(w_i)\) where \( r(w) = \dfrac{\text{exp}(- \mathcal{E}(w))}{Q(w)} \) and \( R = \sum^m_{j=1} r(w_j) \).<br>
Note that we use \( r \) and \( R \) instead of \( w\) and \(W\) as in Bengio and Senécal (2003, 2008) to avoid name clashes. As we can see, we still compute the numerator of the softmax, but replace the normalisation in the denominator with the proposal distribution \(Q\). Our biased estimator that approximates the expectation thus looks like the following:</p>
<p>\( \mathbb{E}_{w_i \sim P}[\nabla_\theta \mathcal{E}(w_i)] \approx  \dfrac{1}{R} \sum\limits^m_{i=1} r(w_i) \nabla_\theta    \mathcal{E}(w_i)\)</p>
<p>Note that the fewer samples we use, the worse is our approximation. We additionally need to adjust our sample size during training, as the network's distribution \(P\) might diverge from the unigram distribution \(Q \) during training, which leads to divergence of the model, if the sample size that is used is too small. Consequently, Bengio and Senécal introduce a measure to calculate the effective sample size in order to protect against possible divergence. Finally, the authors report a speed-up factor of \(19 \) over the regular softmax for this method.</p>
<h2 id="adaptiveimportancesampling">Adaptive Importance Sampling</h2>
<p>Bengio and Senécal (2008) note that for Importance Sampling, substituting more complex distributions, e.g. bigram and trigram distributions, later in training to combat the divergence of the unigram distribution \(Q\) from the model's true distribution \(P\) does not help, as n-gram distributions seem to be quite different from the distribution of trained neural language models. As an alternative, they propose an n-gram distribution that is adapted during training to follow the target distribution \(P\) more closely. To this end, they interpolate a bigram distribution and a unigram distribution according to some mixture function, whose parameters they train with SGD for different frequency bins to minimize the Kullback-Leibler divergence between the distribution \( Q \) and the target distribution \( P\). For experiments, they report a speed-up factor of about \(100\).</p>
<h2 id="targetsampling">Target Sampling</h2>
<p>Jean et al. (2015) propose to use Adaptive Importance Sampling for machine translation. In order to make the method more suitable for processing on a GPU with limited memory, they limit the number of target words that need to be sampled from. They do this by partitioning the training set and including only a fixed number of sample words in every partition, which form a subset \(V'\) of the vocabulary.</p>
<p>This essentially means that a separate proposal distribution \(Q_i \) can be used for every partition \(i\) of the training set, which assigns equal probability to all words included in the vocabulary subset \(V'_i\) and zero probability to all other words.</p>
<h2 id="noisecontrastiveestimation">Noise Contrastive Estimation</h2>
<p>Noise Contrastive Estimation (NCE) (Gutmann and Hyvärinen, 2010) <sup class="footnote-ref"><a href="index.html#fn14" id="fnref14">[14]</a></sup> is proposed by Mnih and Teh (2012) <sup class="footnote-ref"><a href="index.html#fn15" id="fnref15">[15]</a></sup> as a more stable sampling method than Importance Sampling (IS), as we have seen that IS poses the risk of having the proposal distribution \(Q\) diverge from the distribution \(P\) that should be optimized. In contrast to the former, NCE does not try to estimate the probability of a word directly. Instead, it uses an auxiliary loss that also optimises the goal of maximizing the probability of correct words.</p>
<p>Recall the pairwise-ranking criterion of Collobert and Weston (2008) that ranks positive windows higher than &quot;corrupted&quot; windows, which we discussed in the <a href="http://ruder.io/word-embeddings-1/index.html">previous post</a>. NCE does a similar thing: We train a model to differentiate the target word from noise. We can thus reduce the problem of predicting the correct word to a binary classification task, where the model tries to distinguish positive, genuine data from noise samples, as can be seen in Figure 4 below.</p>
<figure>
      <img src="https://ruder.io/content/images/2016/06/negative_sampling.png" style="width: 70%" title="Noise Contrastive Estimation">
<figcaption>Figure 4: Noise Contrastive Estimation (<a href="http://scholar.sun.ac.za/handle/10019.1/98758">Stephan Gouws' PhD dissertation</a>) </figcaption>
</figure>
<p>For every word \(w_i\) given its context \(c_i \) of \(n\) previous words \(w_{t-1} , \cdots , w_{t-n+1}\) in the training set, we thus generate \(k\) noise samples \(\tilde{w}_{ik}\) from a noise distribution \(Q\). As in IS, we can sample from the unigram distribution of the training set. As we need labels to perform our binary classification task, we designate all correct words \(w_i\) given their context \(c_i\) as true (\(y=1\)) and all noise samples \(\tilde{w}_{ik}\) as false (\(y=0\)).</p>
<p>We can now use logistic regression to minimize the negative log-likelihood, i.e. cross-entropy of our training examples against the noise (conversely, we could also maximize the <em>positive</em> log-likelihood as some papers do):</p>
<p>\( J_\theta = - \sum_{w_i \in V} [ \text{log}    P(y=1  |  w_i,c_i) + k    \mathbb{E}_{\tilde{w}_{ik} \sim Q} [   \text{log}    P(y=0   |  \tilde{w}_{ij},c_i)]] \).</p>
<p>Instead of computing the expectation \(\mathbb{E}_{\tilde{w}_{ik} \sim Q}\) of our noise samples, which would still require summing over all words in \(V\) to predict the normalised probability of a negative label, we can again take the mean with the Monte Carlo approximation:</p>
<p>\( J_\theta = - \sum_{w_i \in V} [ \text{log}    P(y=1  |  w_i,c_i) + k    \sum_{j=1}^k \dfrac{1}{k}   \text{log}    P(y=0   |  \tilde{w}_{ij},c_i)] \),</p>
<p>which reduces to:</p>
<p>\( J_\theta = - \sum_{w_i \in V} [ \text{log}    P(y=1  |  w_i,c_i) +    \sum_{j=1}^k   \text{log}    P(y=0   |  \tilde{w}_{ij},c_i)] \),</p>
<p>By generating \(k\) noise samples for every genuine word \(w_i\) given its context \(c\), we are effectively sampling words from two different distributions: Correct words are sampled from the empirical distribution of the training set \(P_{\text{train}}\) and depend on their context \(c\), whereas noise samples come from the noise distribution \(Q\). We can thus represent the probability of sampling either a positive or a noise sample as a mixture of those two distributions, which are weighted based on the number of samples that come from each:</p>
<p>\(P(y, w    |    c) = \dfrac{1}{k+1} P_{\text{train}}(w    |    c)+ \dfrac{k}{k+1}Q(w) \).</p>
<p>Given this mixture, we can now calculate the probability that a sample came from the training \(P_{\text{train}}\) distribution as a conditional probability of \(y\) given \(w\) and \(c\):</p>
<p>\( P(y=1  |  w,c)= \dfrac{\dfrac{1}{k+1} P_{\text{train}}(w    |    c)}{\dfrac{1}{k+1} P_{\text{train}}(w    |    c)+ \dfrac{k}{k+1}Q(w)} \),</p>
<p>which can be simplified to:</p>
<p>\( P(y=1  |  w,c)= \dfrac{P_{\text{train}}(w    |    c)}{P_{\text{train}}(w    |    c) + k    Q(w)} \).</p>
<p>As we don't know \(P_{\text{train}}\) (which is what we would like to calculate), we replace \(P_{\text{train}}\) with the probability of our model \(P\):</p>
<p>\( P(y=1  |  w,c)= \dfrac{P(w    |    c)}{P(w    |    c) + k    Q(w)} \).</p>
<p>The probability of predicting a noise sample (\(y=0\)) is then simply \(P(y=0  |  w,c) = 1 - P(y=1  |  w,c)\). Note that computing \( P(w    |    c) \), i.e. the probability of a word \(w\) given its context \(c\) is essentially the definition of our softmax:</p>
<p>\(P(w    |    c) = \dfrac{\text{exp}({h^\top v'_{w}})}{\sum_{w_i \in V} \text{exp}({h^\top v'_{w_i}})} \).</p>
<p>For notational brevity and unambiguity, let us designate the denominator of the softmax with \(Z(c)\), since the denominator only depends on \(h\), which is generated from \(c\) (assuming a fixed \(V\)). The softmax then looks like this:</p>
<p>\(P(w    |    c) = \dfrac{\text{exp}({h^\top v'_{w}})}{Z(c)} \).</p>
<p>Having to compute \(P(w    |    c)\) means that -- again -- we need to compute \(Z(c)\), which requires us to sum over the probabilities of all words in \(V\). In the case of NCE, there exists a neat trick to circumvent this issue: We can treat the normalisation denominator \(Z(c)\) as a parameter that the model can learn.<br>
Mnih and Teh (2012) and Vaswani et al. (2013) <sup class="footnote-ref"><a href="index.html#fn16" id="fnref16">[16]</a></sup> actually keep \(Z(c)\) fixed at \(1\), which they report does not affect the model's performance. This assumption has the nice side-effect of reducing the model's parameters, while ensuring that the model self-normalises by not depending on the explicit normalisation in \(Z(c)\). Indeed, Zoph et al. (2016) <sup class="footnote-ref"><a href="index.html#fn17" id="fnref17">[17]</a></sup> find that even when learned, \(Z(c)\) is close to \(1\) and has low variance.</p>
<p>If we thus set \(Z(c)\) to \(1\) in the above softmax equation, we are left with the following probability of word \(w\) given a context \(c\):</p>
<p>\(P(w    |    c) = \text{exp}({h^\top v'_{w}})\).</p>
<p>We can now insert this term in the above equation to compute \(P(y=1  |  w,c)\):</p>
<p>\( P(y=1  |  w,c)= \dfrac{\text{exp}({h^\top v'_{w}})}{\text{exp}({h^\top v'_{w}}) + k    Q(w)} \).</p>
<p>Inserting this term in turn in our logistic regression objective finally yields the full NCE loss:</p>
<p>\( J_\theta = - \sum_{w_i \in V} [ \text{log}    \dfrac{\text{exp}({h^\top v'_{w_i}})}{\text{exp}({h^\top v'_{w_i}}) + k    Q(w_i)} + \sum_{j=1}^k   \text{log}    (1 - \dfrac{\text{exp}({h^\top v'_{\tilde{w}_{ij}}})}{\text{exp}({h^\top v'_{\tilde{w}_{ij}}}) + k    Q(\tilde{w}_{ij})})] \).</p>
<p>Note that NCE has nice theoretical guarantees: It can be shown that as we increase the number of noise samples \(k\), the NCE derivative tends towards the gradient of the softmax function. Mnih and Teh (2012) report that \(25\) noise samples are sufficient to match the performance of the regular softmax, with an expected speed-up factor of about \(45\). For more information on NCE, Chris Dyer has published some excellent notes <sup class="footnote-ref"><a href="index.html#fn18" id="fnref18">[18]</a></sup>.</p>
<p>One caveat of NCE is that as typically different noise samples are sampled for every training word \(w\), the noise samples and their gradients cannot be stored in dense matrices, which reduces the benefit of using NCE with GPUs, as it cannot benefit from fast dense matrix multiplications. Jozefowicz et al. (2016) and Zoph et al. (2016) independently propose to share noise samples across all training words in a mini-batch, so that NCE gradients can be computed with dense matrix operations, which are more efficient on GPUs.</p>
<h3 id="similaritybetweennceandis">Similarity between NCE and IS</h3>
<p>Jozefowicz et al. (2016) show that NCE and IS are not only similar as both are sampling-based approaches, but are strongly connected. While NCE uses a binary classification task, they show that IS can be described similarly using a surrogate loss function: Instead of performing binary classification with a logistic loss function like NCE, IS then optimises a multi-class classification problem with a softmax and cross-entropy loss function. They observe that as IS performs multi-class classification, it may be a better choice for language modelling, as the loss leads to tied updates between the data and noise samples rather than independent updates as with NCE. Indeed, Jozefowicz et al. (2016) use IS for language modelling and obtain state-of-the-art performance (as mentioned above) on the 1B Word benchmark.</p>
<h2 id="negativesampling">Negative Sampling</h2>
<p>Negative Sampling (NEG), the objective that has been popularised by Mikolov et al. (2013), can be seen as an approximation to NCE. As we have mentioned above, NCE can be shown to approximate the loss of the softmax as the number of samples \(k\) increases. NEG simplifies NCE and does away with this guarantee, as the objective of NEG is to learn high-quality word representations rather than achieving low perplexity on a test set, as is the goal in language modelling.</p>
<p>NEG also uses a logistic loss function to minimise the negative log-likelihood of words in the training set. Recall that NCE calculated the probability that a word \(w\) comes from the empirical training distribution \(P_{\text{train}}\) given a context \(c\) as follows:</p>
<p>\( P(y=1  |  w,c)= \dfrac{\text{exp}({h^\top v'_{w}})}{\text{exp}({h^\top v'_{w}}) + k    Q(w)} \).</p>
<p>The key difference to NCE is that NEG only approximates this probability by making it as easy to compute as possible. For this reason, it sets the most expensive term, \(k    Q(w)\) to \(1\), which leaves us with:</p>
<p>\( P(y=1  |  w,c)= \dfrac{\text{exp}({h^\top v'_{w}})}{\text{exp}({h^\top v'_{w}}) + 1} \).</p>
<p>\(k    Q(w) = 1\) is exactly then true, when \(k=   |V|\) and \(Q\) is a uniform distribution. In this case, NEG is equivalent to NCE. The reason we set \(k    Q(w) = 1\) and not to some other constant can be seen by rewriting the equation, as \(P(y=1  |  w,c)\) can be transformed into the sigmoid function:</p>
<p>\( P(y=1  |  w,c)= \dfrac{1}{1 + \text{exp}({-h^\top v'_{w}})} \).</p>
<p>If we now insert this back into the logistic regression loss from before, we get:</p>
<p>\( J_\theta = - \sum_{w_i \in V} [ \text{log}    \dfrac{1}{1 + \text{exp}({-h^\top v'_{w_i}})} +    \sum_{j=1}^k   \text{log}    (1 - \dfrac{1}{1 + \text{exp}({-h^\top v'_{\tilde{w}_{ij}}})}] \).</p>
<p>By simplifying slightly, we obtain:</p>
<p>\( J_\theta = - \sum_{w_i \in V} [ \text{log}    \dfrac{1}{1 + \text{exp}({-h^\top v'_{w_i}})} +    \sum_{j=1}^k   \text{log}    (\dfrac{1}{1 + \text{exp}({h^\top v'_{\tilde{w}_{ij}}})}] \).</p>
<p>Setting \(\sigma(x) = \dfrac{1}{1 + \text{exp}({-x})}\) finally yields the NEG loss:</p>
<p>\( J_\theta = - \sum_{w_i \in V} [ \text{log}    \sigma(h^\top v'_{w_i}) +    \sum_{j=1}^k   \text{log}    \sigma(-h^\top v'_{\tilde{w}_{ij}})] \).</p>
<p>To conform with the notation of Mikolov et al. (2013), \(h\) must be replaced with \(v_{w_I}\), \(v'_{w_i}\) with \(v'_{w_O}\) and \(v_{\tilde{w}_{ij}}\) with \(v'_{w_i}\). Also, in contrast to Mikolov's NEG objective, we a) optimise the objective over the whole corpus, b) minimise negative log-likelihood instead of maximising positive log-likelihood (as mentioned before), and c) have already replaced the expectation \(\mathbb{E}_{\tilde{w}_{ik} \sim Q}\) with its Monte Carlo approximation. For more insights on the derivation of NEG, have a look at Goldberg and Levy's notes <sup class="footnote-ref"><a href="index.html#fn19" id="fnref19">[19]</a></sup>.</p>
<p>We have seen that NEG is only equivalent to NCE when \(k=   |V|\) and \(Q\) is uniform. In all other cases, NEG only approximates NCE, which means that it will not directly optimise the likelihood of correct words, which is key for language modelling. While NEG may thus be useful for learning word embeddings, its lack of asymptotic consistency guarantees makes it inappropriate for language modelling.</p>
<h2 id="selfnormalisation">Self-Normalisation</h2>
<p>Even though the self-normalisation technique proposed by Devlin et al. <sup class="footnote-ref"><a href="index.html#fn20" id="fnref20">[20]</a></sup> is not a sampling-based approach, it provides further intuitions on self-normalisation of language models, which we briefly touched upon. We previously mentioned in passing that by setting the denominator \(Z(c)\) of the NCE loss to \(1\), the model essentially self-normalises. This is a useful property as it allows us to skip computing the expensive normalisation in \(Z(c)\).</p>
<p>Recall that our loss function \(J_\theta\) minimises the negative log-likelihood of all words \(w_i\) in our training data:</p>
<p>\(J_\theta = - \sum\limits_i [\text{log}    \dfrac{\text{exp}({h^\top v'_{w_i}})}{Z(c)}] \).</p>
<p>We can decompose the softmax into a sum as we did before:</p>
<p>\(J_\theta    P(w    |    c) = - \sum\limits_i [h^\top v'_{w_i} + \text{log}    Z(c)] \).</p>
<p>If we are able to constrain our model so that it sets \(Z(c) = 1\) or similarly \(\text{log}    Z(c) = 0\), then we can avoid computing the normalisation in \(Z(c)\) altogether. Devlin et al. (2014) thus propose to add a squared error penalty term to the loss function that encourages the model to keep \(\text{log}    Z(c)\) as close as possible to \(0\):</p>
<p>\(J_\theta = - \sum\limits_i [h^\top v'_{w_i} + \text{log}    Z(c) - \alpha   (\text{log}(Z(c)) - 0)^2] \),</p>
<p>which can be rewritten as:</p>
<p>\(J_\theta = - \sum\limits_i [h^\top v'_{w_i} + \text{log}    Z(c) - \alpha    \text{log}^2 Z(c)] \)</p>
<p>where \(\alpha\) allows us to trade-off between model accuracy and mean self-normalisation. By doing this, we can essentially guarantee that \(Z(c)\) will be as close to \(1\) as we want. At decoding time in their MT system, Devlin et al. (2014) then set the denominator of the softmax to \(1\) and only use the numerator for computing \(P(w    |    c)\) together with their penalty term:</p>
<p>\(J_\theta = - \sum\limits_i [h^\top v'_{w_i} - \alpha    \text{log}^2 Z(c)] \)</p>
<p>They report that self-normalisation achieves a speed-up factor of about \(15\), while only resulting in a small degradation of BLEU scores compared to a regular non-self-normalizing neural language model.</p>
<h2 id="infrequentnormalisation">Infrequent Normalisation</h2>
<p>Andreas and Klein (2015) <sup class="footnote-ref"><a href="index.html#fn21" id="fnref21">[21]</a></sup> suggest that it should even be sufficient to only normalise a fraction of the training examples and still obtain approximate self-normalising behaviour. They thus propose Infrequent Normalisation (IN), which down-samples the penalty term, making this a sampling-based approach.</p>
<p>Let us first decompose the sum of the previous loss \(J_\theta\) into two separate sums:</p>
<p>\(J_\theta = - \sum\limits_i h^\top v'_{w_i} +  \alpha \sum\limits_i \text{log}^2 Z(c) \).</p>
<p>We can now down-sample the second term by only computing the normalisation for a subset \(C\) of words \(w_j\) and thus of contexts \(c_j\) (as \(Z(c)\) only depends on the context \(c\)) in the training data:</p>
<p>\(J_\theta = - \sum\limits_i h^\top v'_{w_i} +  \dfrac{\alpha}{\gamma} \sum\limits_{c_j \in C} \text{log}^2 Z(c_j) \)</p>
<p>where \(\gamma\) controls the size of the subset \(C\). Andreas and Klein (2015) suggest that IF combines the strengths of NCE and self-normalisation as it does not require computing the normalisation for all training examples (which NCE avoids entirely), but like self-normalisation allows trading-off between the accuracy of the model and how well normalisation is approximated. They observe a speed-up factor of \(10\) when normalising only a tenth of the training set, with no noticeable performance penalty.</p>
<h3 id="otherapproaches">Other Approaches</h3>
<p>So far, we have focused exclusively on approximating or even entirely avoiding the computation of the softmax denominator \(Z(c)\), as it is the most expensive term in the computation. We have thus not paid particular attention to \(h^\top v'_{w}\), i.e. the dot-product between the penultimate layer representation \(h\) and output word embedding \(v'_{w}\). Vijayanarasimhan et al. (2015) <sup class="footnote-ref"><a href="index.html#fn22" id="fnref22">[22]</a></sup> propose fast locality-sensitive hashing to approximate \(h^\top v'_{w}\). However, while this technique accelerates the model at test time, during training, these speed-ups virtually vanish as embeddings must be re-indexed and the batch size increases.</p>
<h1 id="whichapproachtochoose">Which Approach to Choose?</h1>
<p>Having reviewed the most popular softmax-based and sampling-based approaches, we have shown that there are plenty of alternatives to the good ol' softmax and almost all of them promise a significant speed-up and equivalent or at most marginally deteriorated performance. This naturally poses the question which approach is the best for a particular task.</p>
<figure>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg .tg-e3zv{font-weight:bold}
.tg .tg-9hbo{font-weight:bold;vertical-align:top}
.tg .tg-yw4l{vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-e3zv">Approach</th>
    <th class="tg-e3zv">Speed-up<br>factor</th>
    <th class="tg-e3zv">During<br>training?</th>
    <th class="tg-9hbo">During<br>testing?</th>
    <th class="tg-9hbo">Performance<br>(small vocab)</th>
    <th class="tg-9hbo">Performance<br>(large vocab)</th>
    <th class="tg-9hbo">Proportion of<br>parameters</th>
  </tr>
  <tr>
    <td class="tg-031e">Softmax</td>
    <td class="tg-031e">1x</td>
    <td class="tg-031e">-</td>
    <td class="tg-yw4l">-</td>
    <td class="tg-yw4l">very good</td>
    <td class="tg-yw4l">very poor</td>
    <td class="tg-yw4l">100%</td>
  </tr>
  <tr>
    <td class="tg-yw4l">Hierarchical Softmax</td>
    <td class="tg-yw4l">25x (50-100x)</td>
    <td class="tg-yw4l">X</td>
    <td class="tg-yw4l">-</td>
    <td class="tg-yw4l">very poor</td>
    <td class="tg-yw4l">very good</td>
    <td class="tg-yw4l">100%</td>
  </tr>
  <tr>
    <td class="tg-yw4l">Differentiated Softmax</td>
    <td class="tg-yw4l">2x</td>
    <td class="tg-yw4l">X</td>
    <td class="tg-yw4l">X</td>
    <td class="tg-yw4l">very good</td>
    <td class="tg-yw4l">very good</td>
    <td class="tg-yw4l">&lt; 100%</td>
  </tr>
  <tr>
    <td class="tg-yw4l">CNN-Softmax</td>
    <td class="tg-yw4l">-</td>
    <td class="tg-yw4l">X</td>
    <td class="tg-yw4l">-</td>
    <td class="tg-yw4l">-</td>
    <td class="tg-yw4l">bad - good</td>
    <td class="tg-yw4l">30%</td>
  </tr>
  <tr>
    <td class="tg-yw4l">Importance Sampling</td>
    <td class="tg-yw4l">(19x)</td>
    <td class="tg-yw4l">X</td>
    <td class="tg-yw4l">-</td>
    <td class="tg-yw4l">-</td>
    <td class="tg-yw4l">-</td>
    <td class="tg-yw4l">100%</td>
  </tr>
  <tr>
    <td class="tg-yw4l">Adaptive<br>Importance Sampling</td>
    <td class="tg-yw4l">(100x)</td>
    <td class="tg-yw4l">X</td>
    <td class="tg-yw4l">-</td>
    <td class="tg-yw4l">-</td>
    <td class="tg-yw4l">-</td>
    <td class="tg-yw4l">100%</td>
  </tr>
  <tr>
    <td class="tg-yw4l">Target Sampling</td>
    <td class="tg-yw4l">2x</td>
    <td class="tg-yw4l">X</td>
    <td class="tg-yw4l">-</td>
    <td class="tg-yw4l">good</td>
    <td class="tg-yw4l">bad</td>
    <td class="tg-yw4l">100%</td>
  </tr>
  <tr>
    <td class="tg-yw4l">Noise Contrastive<br>Estimation</td>
    <td class="tg-yw4l">8x (45x)</td>
    <td class="tg-yw4l">X</td>
    <td class="tg-yw4l">-</td>
    <td class="tg-yw4l">very bad</td>
    <td class="tg-yw4l">very bad</td>
    <td class="tg-yw4l">100%</td>
  </tr>
  <tr>
    <td class="tg-yw4l">Negative Sampling</td>
    <td class="tg-yw4l">(50-100x)</td>
    <td class="tg-yw4l">X</td>
    <td class="tg-yw4l">-</td>
    <td class="tg-yw4l">-</td>
    <td class="tg-yw4l">-</td>
    <td class="tg-yw4l">100%</td>
  </tr>
  <tr>
    <td class="tg-yw4l">Self-Normalisation</td>
    <td class="tg-yw4l">(15x)</td>
    <td class="tg-yw4l">X</td>
    <td class="tg-yw4l">-</td>
    <td class="tg-yw4l">-</td>
    <td class="tg-yw4l">-</td>
    <td class="tg-yw4l">100%</td>
  </tr>
  <tr>
    <td class="tg-yw4l">Infrequent<br>Normalisation</td>
    <td class="tg-yw4l">6x (10x)</td>
    <td class="tg-yw4l">X</td>
    <td class="tg-yw4l">-</td>
    <td class="tg-yw4l">very good</td>
    <td class="tg-yw4l">good</td>
    <td class="tg-yw4l">100%</td>
  </tr>
</table>
<figcaption>Table 1: Comparison of approaches to approximate the softmax for language modelling.</figcaption>
</figure>
<p>We compare the performance of the approaches we discussed in this post for language modelling in Table 1. Speed-up factors and performance are based on the experiments by Chen et al. (2015), while we show speed-up factors reported by the authors of the original papers in brackets. The third and fourth columns indicate if the speed-up is achieved during training and testing respectively. Note that divergence of speed-up factors might be due to unoptimised implementations or the fact that the original authors might not have had access to GPUs, which benefit the regular softmax more than some of the other approaches. Performance for approaches where no comparison is available should largely be analogous to similar approaches, i.e. Self-Normalisation should achieve similar performance as Infrequent Normalisation and Importance Sampling and Adaptive Importance Sampling should achieve similar performance as Target Sampling. The performance of CNN-Softmax is as reported by Jozefowicz et al. (2016) and ranges from bad to good depending on the size of the correction. Of all approaches, only CNN-Softmax achieves a substantial reduction in parameters as the other approaches still require storing output embeddings. Differentiated Softmax reduces parameters by being able to store a sparse weight matrix.</p>
<p>As it always is, there is no clear winner that beats all other approaches on all datasets or tasks. For language modelling, the regular softmax still achieves very good performance on small vocabulary datasets, such as the Penn Treebank, and even performs well on medium datasets, such as Gigaword, but does very poorly on large vocabulary datasets, e.g. the 1B Word Benchmark. Target Sampling, Hierarchical Softmax, and Infrequent Normalisation in turn do better with large vocabularies.<br>
Differentiated Softmax generally does well for both small and large vocabularies and is the only approach that ensures a speed-up at test time. Interestingly, Hierarchical Softmax (HS) performs very poorly with small vocabularies. However, of all methods, HS is the fastest and processes most training examples in a given time frame. While NCE performs well with large vocabularies, it is generally worse than the other methods. Negative Sampling does not work well for language modelling, but it is generally superior for learning word representations, as attested by word2vec's success. Note that all results should be taken with a grain of salt: Chen et al. (2015) report having difficulties using Noise Contrastive Estimation in practice; Kim et al. (2016) use Hierarchical Softmax to achieve state-of-the-art with a small vocabulary, while Importance Sampling is used by the state-of-the-art language model by Jozefowicz et al. (2016) on a dataset with a large vocabulary.</p>
<p>Finally, if you are looking to actually use the described methods, TensorFlow has <a href="https://www.tensorflow.org/versions/master/api_docs/python/nn.html#candidate-sampling">implementations</a> for a few sampling-based approaches and also explains the differences between some of them <a href="https://www.tensorflow.org/extras/candidate_sampling.pdf">here</a>.</p>
<h1 id="conclusion">Conclusion</h1>
<p>This overview of different methods to approximate the softmax attempted to provide you with intuitions that can not only be applied to improve and speed-up learning word representations, but are also relevant for language modelling and machine translation. As we have seen, most of these approaches are closely related and are driven by one uniting factor: the necessity to approximate the expensive normalisation in the denominator of the softmax. With these approaches in mind, I hope you feel now better equipped to train and understand your models and that you might even feel ready to work on learning better word representations yourself.</p>
<p>As we have seen, learning word representations is a vast field and many factors are relevant for success. In the previous blog post, we looked at the architectures of popular models and in this blog post, we investigated more closely a key component, the softmax layer. In the next one, we will introduce GloVe, a method that relies on matrix factorisation rather than language modelling, and turn our attention to other hyperparameters that are essential for successfully learning word embeddings.</p>
<p><strong>As always, let me know about any mistakes I made and approaches I missed in the comments below.</strong></p>
<h2 id="citation">Citation</h2>
<p>For attribution in academic contexts or books, please cite this work as:</p>
<pre><code>Sebastian Ruder. On word embeddings - Part 2: Approximating the Softmax. http://ruder.io/word-embeddings-softmax, 2016.
</code></pre>
<p>BibTeX citation:</p>
<pre><code>@misc{ruder2016wordembeddingspart2,
author = {Ruder, Sebastian},
title = {{On word embeddings - Part 2: Approximating the Softmax}},
year = {2016},
howpublished = {\url{http://ruder.io/word-embeddings-softmax}},
}
</code></pre>
</p>
<h1 id="otherblogpostsonwordembeddings">Other blog posts on word embeddings</h1>
<p>If you want to learn more about word embeddings, these other blog posts on word embeddings are also available:</p>
<ul>
<li><a href="http://ruder.io/word-embeddings-1/index.html">On word embeddings - Part 1</a></li>
<li><a href="http://ruder.io/secret-word2vec/index.html">On word embeddings - Part 3: The secret ingredients of word2vec</a></li>
<li><a href="http://ruder.io/cross-lingual-embeddings/index.html">Unofficial Part 4: A survey of cross-lingual embedding models</a></li>
<li><a href="http://ruder.io/word-embeddings-2017/index.html">Unofficial Part 5: Word embeddings in 2017 -  Trends and future directions</a></li>
</ul>
<h1 id="translations">Translations</h1>
<p>This blog post has been translated into the following languages:</p>
<ul>
<li><a href="http://geek.csdn.net/news/detail/135736">Chinese</a></li>
</ul>
<p>Credit for the cover image goes to <a href="http://stephangouws.com/">Stephan Gouws</a> who included the image in his <a href="http://scholar.sun.ac.za/handle/10019.1/98758">PhD dissertation</a> and in the <a href="https://www.tensorflow.org/versions/r0.9/tutorials/word2vec/index.html">Tensorflow word2vec tutorial</a>.</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Jean, S., Cho, K., Memisevic, R., &amp; Bengio, Y. (2015). On Using Very Large Target Vocabulary for Neural Machine Translation. Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers), 1–10. Retrieved from <a href="http://www.aclweb.org/anthology/P15-1001">http://www.aclweb.org/anthology/P15-1001</a> <a href="index.html#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Jozefowicz, R., Vinyals, O., Schuster, M., Shazeer, N., &amp; Wu, Y. (2016). Exploring the Limits of Language Modeling. Retrieved from <a href="http://arxiv.org/abs/1602.02410">http://arxiv.org/abs/1602.02410</a> <a href="index.html#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Morin, F., &amp; Bengio, Y. (2005). Hierarchical Probabilistic Neural Network Language Model. Aistats, 5. <a href="index.html#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>Rong, X. (2014). word2vec Parameter Learning Explained. arXiv:1411.2738, 1–19. Retrieved from <a href="http://arxiv.org/abs/1411.2738">http://arxiv.org/abs/1411.2738</a> <a href="index.html#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>Mnih, A., &amp; Hinton, G. E. (2008). A Scalable Hierarchical Distributed Language Model. Advances in Neural Information Processing Systems, 1–8. Retrieved from <a href="http://papers.nips.cc/paper/3583-a-scalable-hierarchical-distributed-language-model.pdf">http://papers.nips.cc/paper/3583-a-scalable-hierarchical-distributed-language-model.pdf</a> <a href="index.html#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>Mikolov, T., Chen, K., Corrado, G., &amp; Dean, J. (2013). Distributed Representations of Words and Phrases and their Compositionality. NIPS, 1–9. <a href="index.html#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>Shannon, C. E. (1951). Prediction and Entropy of Printed English. Bell System Technical Journal, 30(1), 50–64. <a href="http://doi.org/10.1002/j.1538-7305.1951.tb01366.x">http://doi.org/10.1002/j.1538-7305.1951.tb01366.x</a> <a href="index.html#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>Chen, W., Grangier, D., &amp; Auli, M. (2015). Strategies for Training Large Vocabulary Neural Language Models. Retrieved from <a href="http://arxiv.org/abs/1512.04906">http://arxiv.org/abs/1512.04906</a> <a href="index.html#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>Kim, Y., Jernite, Y., Sontag, D., &amp; Rush, A. M. (2016). Character-Aware Neural Language Models. AAAI. Retrieved from <a href="http://arxiv.org/abs/1508.06615">http://arxiv.org/abs/1508.06615</a> <a href="index.html#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>Ling, W., Trancoso, I., Dyer, C., &amp; Black, A. W. (2016). Character-based Neural Machine Translation. ICLR, 1–11. Retrieved from <a href="http://arxiv.org/abs/1511.04586">http://arxiv.org/abs/1511.04586</a> <a href="index.html#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>Bengio, Y., &amp; Senécal, J.-S. (2003). Quick Training of Probabilistic Neural Nets by Importance Sampling. AISTATS. <a href="http://www.iro.umontreal.ca/~lisa/pointeurs/submit_aistats2003.pdf">http://www.iro.umontreal.ca/~lisa/pointeurs/submit_aistats2003.pdf</a> <a href="index.html#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>Bengio, Y., &amp; Senécal, J.-S. (2008). Adaptive importance sampling to accelerate training of a neural probabilistic language model. IEEE Transactions on Neural Networks, 19(4), 713–722. <a href="http://doi.org/10.1109/TNN.2007.912312">http://doi.org/10.1109/TNN.2007.912312</a> <a href="index.html#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>Liu, J. S. (2001). Monte Carlo Strategies in Scientific Computing. Springer. <a href="http://doi.org/10.1017/CBO9781107415324.004">http://doi.org/10.1017/CBO9781107415324.004</a> <a href="index.html#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>Gutmann, M., &amp; Hyvärinen, A. (2010). Noise-contrastive estimation: A new estimation principle for unnormalized statistical models. International Conference on Artificial Intelligence and Statistics, 1–8. Retrieved from <a href="http://www.cs.helsinki.fi/u/ahyvarin/papers/Gutmann10AISTATS.pdf">http://www.cs.helsinki.fi/u/ahyvarin/papers/Gutmann10AISTATS.pdf</a> <a href="index.html#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>Mnih, A., &amp; Teh, Y. W. (2012). A Fast and Simple Algorithm for Training Neural Probabilistic Language Models. Proceedings of the 29th International Conference on Machine Learning (ICML’12), 1751–1758. <a href="index.html#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>Vaswani, A., Zhao, Y., Fossum, V., &amp; Chiang, D. (2013). Decoding with Large-Scale Neural Language Models Improves Translation. Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing (EMNLP 2013), (October), 1387–1392. <a href="index.html#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>Zoph, B., Vaswani, A., May, J., &amp; Knight, K. (2016). Simple, Fast Noise-Contrastive Estimation for Large RNN Vocabularies. NAACL. <a href="index.html#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>Dyer, C. (2014). Notes on Noise Contrastive Estimation and Negative Sampling. Arxiv preprint. Retrieved from <a href="http://arxiv.org/abs/1410.8251">http://arxiv.org/abs/1410.8251</a> <a href="index.html#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>Goldberg, Y., &amp; Levy, O. (2014). word2vec Explained: Deriving Mikolov et al.’s Negative-Sampling Word-Embedding Method. arXiv Preprint arXiv:1402.3722, (2), 1–5. Retrieved from <a href="http://arxiv.org/abs/1402.3722">http://arxiv.org/abs/1402.3722</a> <a href="index.html#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>Devlin, J., Zbib, R., Huang, Z., Lamar, T., Schwartz, R., &amp; Makhoul, J. (2014). Fast and robust neural network joint models for statistical machine translation. Proc. ACL’2014, 1370–1380. <a href="index.html#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>Andreas, J., &amp; Klein, D. (2015). When and why are log-linear models self-normalizing? Naacl-2015, 244–249. <a href="index.html#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>Vijayanarasimhan, S., Shlens, J., Monga, R., &amp; Yagnik, J. (2015). Deep Networks With Large Output Spaces. Iclr, 1–9. Retrieved from <a href="http://arxiv.org/abs/1412.7479">http://arxiv.org/abs/1412.7479</a> <a href="index.html#fnref22" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
<!--kg-card-end: markdown-->
                </div>

<h2 id="citation">Newsletter</h2>

<style>
input {
  color: black;
}
</style>

If you want to receive regular updates about advances in machine learning and natural language processing, subscribe to <a href="https://newsletter.ruder.io/">my newsletter</a> below. 

<div id="revue-embed">
  <form action="https://newsletter.ruder.io/add_subscriber" method="post" id="revue-form" name="revue-form" $
  <div class="revue-form-group">
    <label for="member_email">Email address: </label>
    <input class="revue-form-field" placeholder="Your email address" type="email" name="member[email]" id="$
  </div>
  <div class="revue-form-group">
    <label for="member_first_name">First name <span class="optional">(Optional)</span>:</label>
    <input class="revue-form-field" placeholder="First name " type="text" name="member[first_name]" id="memb$
  </div>
  <div class="revue-form-group">
    <label for="member_last_name">Last name <span class="optional">(Optional)</span>:</label>
    <input class="revue-form-field" placeholder="Last name" type="text" name="member[last_name]" id="member$
  </div>
  <div class="revue-form-actions">
    <input type="submit" value="Subscribe" name="member[subscribe]" id="member_submit">
  </div>
  </form>
</div>

            </section>



        </article>

    </div>
</main>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = '/word-embeddings-softmax/';  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = "ghost-17"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://EXAMPLE.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            

<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
                <article class="read-next-card">
                    <header class="read-next-card-header">
                        <h3><span>More in</span> <a href="../tag/word-embeddings/index.html">word embeddings</a></h3>
                    </header>
                    <div class="read-next-card-content">
                        <ul>
                            <li>
                                <h4><a href="../aaai-2019-highlights/index.html">AAAI 2019 Highlights: Dialogue, reproducibility, and more</a></h4>
                                <div class="read-next-card-meta">
                                    <p><time datetime="2019-02-07">7 Feb 2019</time> –
                                        11 min read</p>
                                </div>
                            </li>
                            <li>
                                <h4><a href="../emnlp-2018-highlights/index.html">EMNLP 2018 Highlights: Inductive bias, cross-lingual learning, and more</a></h4>
                                <div class="read-next-card-meta">
                                    <p><time datetime="2018-11-06">6 Nov 2018</time> –
                                        11 min read</p>
                                </div>
                            </li>
                            <li>
                                <h4><a href="../a-review-of-the-recent-history-of-nlp/index.html">A Review of the Neural History of Natural Language Processing</a></h4>
                                <div class="read-next-card-meta">
                                    <p><time datetime="2018-10-01">1 Oct 2018</time> –
                                        29 min read</p>
                                </div>
                            </li>
                        </ul>
                    </div>
                    <footer class="read-next-card-footer">
                        <a href="../tag/word-embeddings/index.html">See all 9 posts
                            →</a>
                    </footer>
                </article>

                <article class="post-card post tag-events tag-natural-language-processing ">

    <a class="post-card-image-link" href="../lisbon-machine-learning-summer-school-highlights/index.html">
        <img class="post-card-image"
            srcset="../content/images/size/w300/2016/08/group_picture-1.jpg 300w,
                   ../content/images/size/w600/2016/08/group_picture-1.jpgg 600w,
                  ../content/images/size/w1000/2016/08/group_picture-1.jpg 1000w,
                 ../content/images/size/w2000/2016/08/group_picture-1.jpg 2000w"
            sizes="(max-width: 1000px) 400px, 700px"
            src="../content/images/size/w600/2016/08/group_picture-1.jpg"
            alt="LxMLS 2016 Highlights"
        />
    </a>

    <div class="post-card-content">

        <a class="post-card-content-link" href="../lisbon-machine-learning-summer-school-highlights/index.html">

            <header class="post-card-header">
                    <div class="post-card-primary-tag">events</div>
                <h2 class="post-card-title">LxMLS 2016 Highlights</h2>
            </header>

            <section class="post-card-excerpt">
                    <p>The Lisbon Machine Learning School (LxMLS) is an annual event that brings together researchers and graduate students in ML, NLP, and Computational Linguistics. This post discusses highlights, key insights, and takeaways from the 6th edition of the summer school.</p>
            </section>

        </a>

        <footer class="post-card-meta">
            <ul class="author-list">
                <li class="author-list-item">
            
                    <div class="author-name-tooltip">
                        Sebastian Ruder
                    </div>
            
                    <a href="../author/sebastian/index.html" class="static-avatar">
                        <img class="author-profile-image" src="../content/images/size/w100/2019/02/new_profile_photo_square-1.jpg" alt="Sebastian Ruder" />
                    </a>
                </li>
            </ul>
            <div class="post-card-byline-content">
                <span><a href="../author/sebastian/index.html">Sebastian Ruder</a></span>
                <span class="post-card-byline-date"><time datetime="2016-08-12">12 Aug 2016</time> <span class="bull">&bull;</span> 14 min read</span>
            </div>
        </footer>

    </div>

</article>

                <article class="post-card post tag-word-embeddings tag-natural-language-processing tag-language-models ">

    <a class="post-card-image-link" href="../word-embeddings-1/index.html">
        <img class="post-card-image"
            srcset="../content/images/size/w300/2016/04/word_embeddings_colah.png 300w,
                   ../content/images/size/w600/2016/04/word_embeddings_colah.png 600w,
                  ../content/images/size/w1000/2016/04/word_embeddings_colah.png 1000w,
                 ../content/images/size/w2000/2016/04/word_embeddings_colah.png 2000w"
            sizes="(max-width: 1000px) 400px, 700px"
            src="../content/images/size/w600/2016/04/word_embeddings_colah.png"
            alt="On word embeddings - Part 1"
        />
    </a>

    <div class="post-card-content">

        <a class="post-card-content-link" href="../word-embeddings-1/index.html">

            <header class="post-card-header">
                    <div class="post-card-primary-tag">word embeddings</div>
                <h2 class="post-card-title">On word embeddings - Part 1</h2>
            </header>

            <section class="post-card-excerpt">
                    <p>Word embeddings popularized by word2vec are pervasive in current NLP applications. The history of word embeddings, however, goes back a lot further. This post explores the history of word embeddings in the context of language modelling.</p>
            </section>

        </a>

        <footer class="post-card-meta">
            <ul class="author-list">
                <li class="author-list-item">
            
                    <div class="author-name-tooltip">
                        Sebastian Ruder
                    </div>
            
                    <a href="../author/sebastian/index.html" class="static-avatar">
                        <img class="author-profile-image" src="../content/images/size/w100/2019/02/new_profile_photo_square-1.jpg" alt="Sebastian Ruder" />
                    </a>
                </li>
            </ul>
            <div class="post-card-byline-content">
                <span><a href="../author/sebastian/index.html">Sebastian Ruder</a></span>
                <span class="post-card-byline-date"><time datetime="2016-04-11">11 Apr 2016</time> <span class="bull">&bull;</span> 15 min read</span>
            </div>
        </footer>

    </div>

</article>
        </div>
    </div>
</aside>




        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://ruder.io">Sebastian Ruder</a> &copy; 2022</section>
                <nav class="site-footer-nav">
                    <a href="https://ruder.io">Latest Posts</a>
                    
                    <a href="https://twitter.com/seb_ruder" target="_blank" rel="noopener">Twitter</a>
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>


    <script
        src="https://code.jquery.com/jquery-3.4.1.min.js"
        integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
        crossorigin="anonymous">
    </script>
    <script src="../assets/built/casper.js?v=aa9afcc559"></script>

    <script>
        // Parse the URL parameter
        function getParameterByName(name, url) {
            if (!url) url = window.location.href;
            name = name.replace(/[\[\]]/g, "\\$&");
            var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
                results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, " "));
        }

        // Give the parameter a variable name
        var action = getParameterByName('action');

        $(document).ready(function () {
            if (action == 'subscribe') {
                $('body').addClass("subscribe-success");
            }

            $('.subscribe-success-message .subscribe-close').click(function () {
                $('.subscribe-success-message').addClass('close');
            });

            // Reset form on opening subscrion overlay
            $('.subscribe-button').click(function() {
                $('.subscribe-overlay form').removeClass();
                $('.subscribe-email').val('');
            });
        });
    </script>

    <script>
    $(document).ready(function () {
        // FitVids - start
        var $postContent = $(".post-full-content");
        $postContent.fitVids();
        // FitVids - end

        // Replace nav with title on scroll - start
        Casper.stickyNavTitle({
            navSelector: '.site-nav-main',
            titleSelector: '.post-full-title',
            activeClass: 'nav-post-title-active'
        });
        // Replace nav with title on scroll - end

        // Hover on avatar
        var hoverTimeout;
        $('.author-list-item').hover(function () {
            var $this = $(this);

            clearTimeout(hoverTimeout);

            $('.author-card').removeClass('hovered');
            $(this).children('.author-card').addClass('hovered');

        }, function () {
            var $this = $(this);

            hoverTimeout = setTimeout(function () {
                $this.children('.author-card').removeClass('hovered');
            }, 800);
        });
    });
</script>


    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.1.6/zepto.min.js"></script>
<script>jQuery = Zepto</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/themes/prism.min.css" />
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/plugins/line-numbers/prism-line-numbers.min.css" />
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/themes/prism-coy.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-python.min.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-60512592-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-60512592-1');
</script>

</body>
</html>
